<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CHM13v2.0 Segmental Duplications Dashboard</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- DataTables Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/datatables.net-bs5/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    <!-- vis-network CSS -->
    <link href="https://cdn.jsdelivr.net/npm/vis-network/styles/vis-network.min.css" rel="stylesheet">
    <!-- LZString for compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
    <style>
        /* Global styles */
        body {
            font-family: 'Roboto', sans-serif;
            background: #f4f7fa;
            overflow-x: hidden;
        }

        header {
            background: linear-gradient(135deg, #007bff, #00c6ff);
            color: #fff;
            padding: 2rem 1rem;
            text-align: center;
        }

        /* Main container card */
        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }

        .tag-input {
            border: 1px solid #ccc;
            padding: 0.5rem;
            min-height: 3rem;
            cursor: text;
            background: #fff;
            border-radius: 4px;
        }

        .tag {
            background: #007bff;
            color: #fff;
            padding: 0.2rem 0.5rem;
            margin: 0.2rem;
            border-radius: 5px;
            display: inline-block;
        }

        .tag-remove {
            margin-left: 5px;
            cursor: pointer;
        }

        .autocomplete-suggestions {
            background: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            z-index: 1000;
            width: 100%;
            border-radius: 4px;
        }

        .autocomplete-suggestion {
            padding: 0.5rem;
            cursor: pointer;
        }

        .autocomplete-suggestion:hover {
            background: #f0f0f0;
        }

        #graphContainer {
            height: 500px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 1rem;
            margin-bottom: 1rem;
            display: none;
        }

        footer {
            text-align: center;
            padding: 1rem;
            border-top: 1px solid #ccc;
            font-size: 0.9rem;
            color: #666;
            margin-top: 2rem;
        }

        .card {
            border: none;
            margin-bottom: 1rem;
        }

        .card-body {
            padding: 1rem 1.5rem;
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header>
        <h1>CHM13v2.0 Segmental Duplications Dashboard</h1>
        <p class="lead">Explore, filter segmental duplications.</p>
    </header>

    <!-- Main Content Container -->
    <div class="main-container">
        <!-- Gene Input Section -->
        <div class="mb-4">
            <label class="form-label">Search genes (comma-separated, case-insensitive):</label>
            <div id="geneTags" class="tag-input" contenteditable="true"></div>
            <div id="suggestions" class="autocomplete-suggestions"></div>
            <button type="button" id="loadExample" class="btn btn-info btn-sm mt-2">Load Example Genes</button>
        </div>

        <!-- Dynamic Filters Section -->
        <div class="card mb-4">
            <div class="card-body">
                <h6 class="fw-bold">Dynamic Filters</h6>
                <div id="dynamicFiltersContainer"></div>
                <button type="button" id="addFilter" class="btn btn-primary btn-sm mt-2">Add Filter</button>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="row mb-4 g-2">
            <div class="col-auto">
                <button type="button" id="applyFilters" class="btn btn-secondary">Apply Filters</button>
            </div>
            <div class="col-auto">
                <button type="button" id="visualizeGraph" class="btn btn-warning">üï∏ Visualize Graph</button>
            </div>
            <div class="col-auto">
                <button type="button" id="downloadZip" class="btn btn-success">‚¨áÔ∏è Download ZIP</button>
            </div>
            <div class="col-auto">
                <button type="button" id="shareResults" class="btn btn-info">Share Results</button>
            </div>
        </div>

        <!-- File Downloads Section -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="mb-2">
                    <label for="filePrefix" class="form-label">File Prefix (optional):</label>
                    <input type="text" class="form-control form-control-sm" id="filePrefix"
                        placeholder="e.g. myResults_">
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <button type="button" id="downloadNodesTsv" class="btn btn-outline-primary btn-sm">Download Nodes
                        TSV</button>
                    <button type="button" id="downloadEdgesTsv" class="btn btn-outline-primary btn-sm">Download Edges
                        TSV</button>
                    <button type="button" id="downloadNodesBed" class="btn btn-outline-primary btn-sm">Download Nodes
                        BED</button>
                    <button type="button" id="downloadFullEdgesTsv" class="btn btn-outline-primary btn-sm">Download Full
                        Component Edges TSV</button>
                    <button type="button" id="downloadFullNodesBed" class="btn btn-outline-primary btn-sm">Download Full
                        Component Nodes BED</button>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div id="statsBox" class="alert alert-info d-none mb-4" style="padding: 0.5rem;"></div>

        <!-- Data Tables -->
        <h6 class="mb-2">üìç Filtered Nodes</h6>
        <div class="table-responsive mb-4">
            <table id="nodesTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>
        <h6 class="mb-2">üîó Filtered Edges</h6>
        <div class="table-responsive mb-4">
            <table id="edgesTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>

        <!-- Graph Container -->
        <div id="graphContainer"></div>
    </div>

    <!-- Footer -->
    <footer>
        Developed by <a href="https://github.com/mr-eyes/" target="_blank">Mohamed Abuelanin</a> in <a
            href="https://www.dennislab.org/" target="_blank">Megan Dennis lab</a>
    </footer>

    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net/js/dataTables.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net-bs5/js/dataTables.bootstrap5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- App Logic -->
    <script>
        let nodesData = [],
            edgesData = [],
            geneList = [],
            selectedGenes = [],
            nodesColumns = [],
            nodesColumnTypes = {};

        // Helper: Download file
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
        }

        // Convert array to TSV string.
        function toTSV(arr) {
            const keys = Object.keys(arr[0] || {});
            return [keys.join("\t")].concat(arr.map(obj => keys.map(k => obj[k]).join("\t"))).join("\n");
        }

        // Convert nodes to BED format.
        function toBED(nodes) {
            return nodes.map(n => {
                const [chr, rng] = n.id.split(":");
                const [s, e] = rng.split("-");
                return `${chr}\t${s}\t${e}`;
            }).join("\n");
        }

        // Load TSV files.
        function loadTSV(file, callback) {
            fetch(file).then(r => r.text()).then(t => {
                const [h, ...lines] = t.trim().split("\n");
                const keys = h.split("\t");
                const data = lines.map(line => {
                    const obj = {};
                    line.split("\t").forEach((val, i) => obj[keys[i]] = val);
                    return obj;
                });
                callback(data, keys);
            });
        }

        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/\\/g, '\\\\')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Manage gene tags.
        function updateGeneTags() {
            const box = document.getElementById("geneTags");
            box.innerHTML = "";
            selectedGenes.forEach(g => {
                const span = document.createElement("span");
                span.className = "tag";
                span.textContent = g;
                span.setAttribute("data-gene", g);
                const remove = document.createElement("span");
                remove.className = "tag-remove";
                remove.innerHTML = "&times;";
                remove.onclick = () => {
                    selectedGenes = selectedGenes.filter(x => x !== g);
                    updateGeneTags();
                };
                span.appendChild(remove);
                box.appendChild(span);
                box.appendChild(document.createTextNode(" "));
            });
        }

        // Autocomplete for gene names.
        function autocomplete(input) {
            const match = input.toLowerCase();
            const hits = geneList.filter(g => g.toLowerCase().includes(match) && g.length >= input.length).slice(0, 10);
            const box = document.getElementById("suggestions");
            box.innerHTML = hits.map(g => `<div class="autocomplete-suggestion">${g}</div>`).join('');
            document.querySelectorAll('.autocomplete-suggestion').forEach(el => {
                el.onclick = () => {
                    const gene = el.textContent.trim();
                    if (!selectedGenes.includes(gene)) selectedGenes.push(gene);
                    updateGeneTags();
                    box.innerHTML = '';
                };
            });
        }

        // Retrieve gene selections.
        function getSelectedGenesFromBox() {
            const spans = document.querySelectorAll("#geneTags span.tag");
            selectedGenes = Array.from(spans).map(span => span.getAttribute("data-gene"));
        }

        // Load example genes.
        document.getElementById("loadExample").addEventListener("click", () => {
            const exampleGenes = ["ARHGAP11A", "CD8B", "DUSP22", "FAM72A", "GPR89A", "HYDIN", "PDZK1", "ROCK1", "SRGAP2"];
            selectedGenes = exampleGenes;
            updateGeneTags();
        });

        // Dynamic Filter Module.
        function addDynamicFilterRow() {
            const container = document.getElementById("dynamicFiltersContainer");
            const row = document.createElement("div");
            row.className = "row dynamic-filter-row mb-2 align-items-center";
            row.innerHTML = `
        <div class="col-4 col-sm-4 col-md-5">
          <select class="form-select form-select-sm filter-column">
            <option value="" disabled selected>Select column</option>
          </select>
        </div>
        <div class="col-6 col-sm-6 col-md-5 filter-input-container">
          <!-- Dynamic input will appear here -->
        </div>
        <div class="col-2 col-sm-2 col-md-2 text-end">
          <button type="button" class="btn btn-danger btn-sm remove-filter">X</button>
        </div>
      `;
            const select = row.querySelector(".filter-column");
            select.innerHTML += nodesColumns.map(col => `<option value="${escapeHTML(col)}">${escapeHTML(col)}</option>`).join('');
            select.addEventListener("change", function () {
                updateFilterInput(row, this.value);
            });
            row.querySelector(".remove-filter").addEventListener("click", () => row.remove());
            container.appendChild(row);
        }

        // Update dynamic filter input based on column type.
        function updateFilterInput(filterRow, column) {
            const container = filterRow.querySelector(".filter-input-container");
            const colType = nodesColumnTypes[column];
            if (colType === "number") {
                const uniqueValues = [...new Set(nodesData.map(n => n[column]))];
                const isBoolean = uniqueValues.length === 2 && uniqueValues.includes("0") && uniqueValues.includes("1");
                if (isBoolean) {
                    container.innerHTML = `
            <select class="form-select form-select-sm filter-boolean">
              <option value="" selected>Select</option>
              <option value="1">True</option>
              <option value="0">False</option>
            </select>
          `;
                } else {
                    container.innerHTML = `
            <div class="input-group input-group-sm">
              <span class="input-group-text">Min</span>
              <input type="number" class="form-control filter-min" placeholder="Min">
              <span class="input-group-text">Max</span>
              <input type="number" class="form-control filter-max" placeholder="Max">
            </div>
          `;
                }
            } else {
                const uniqueValues = [...new Set(nodesData.map(n => n[column]))].sort();
                const optionsHTML = uniqueValues.map(v => `<option value="${escapeHTML(v)}">${escapeHTML(v)}</option>`).join('');
                container.innerHTML = `
          <select multiple class="form-select form-select-sm filter-values" size="3">
            ${optionsHTML}
          </select>
          <div class="form-check mt-1">
            <input class="form-check-input filter-exclude" type="checkbox" id="exclude-${column}">
            <label class="form-check-label" for="exclude-${column}" style="font-size: 0.85rem;">Exclude</label>
          </div>
        `;
            }
        }

        // Build share state from gene selection and dynamic filters.
        function getShareState() {
            const state = {};
            state.genes = selectedGenes;
            state.filters = [];
            const dynamicFilters = document.querySelectorAll(".dynamic-filter-row");
            dynamicFilters.forEach(row => {
                const col = row.querySelector(".filter-column").value;
                if (!col) return;
                const filter = { column: col, type: nodesColumnTypes[col] };
                if (filter.type === "number") {
                    const boolSelect = row.querySelector(".filter-boolean");
                    if (boolSelect) {
                        filter.value = boolSelect.value;
                    } else {
                        filter.min = row.querySelector(".filter-min").value;
                        filter.max = row.querySelector(".filter-max").value;
                    }
                } else {
                    const selectEl = row.querySelector(".filter-values");
                    filter.values = Array.from(selectEl.selectedOptions).map(opt => opt.value);
                    filter.exclude = row.querySelector(".filter-exclude").checked;
                }
                state.filters.push(filter);
            });
            return state;
        }

        // Update URL with compressed share state and copy to clipboard.
        function shareResults() {
            const state = getShareState();
            const stateStr = LZString.compressToEncodedURIComponent(JSON.stringify(state));
            const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?shareState=" + stateStr;
            window.history.pushState({ path: newUrl }, '', newUrl);
            navigator.clipboard.writeText(newUrl).then(() => {
                const shareBtn = document.getElementById("shareResults");
                shareBtn.textContent = "Link Copied!";
                setTimeout(() => { shareBtn.textContent = "Share Results"; }, 2000);
            }).catch(err => { console.error("Could not copy link: ", err); });
        }

        // Restore share state from URL if present.
        function loadShareState() {
            const params = new URLSearchParams(window.location.search);
            if (params.has("shareState")) {
                try {
                    const compressedState = params.get("shareState");
                    const state = JSON.parse(LZString.decompressFromEncodedURIComponent(compressedState));
                    if (state.genes) {
                        selectedGenes = state.genes;
                        updateGeneTags();
                    }
                    if (state.filters) {
                        state.filters.forEach(filter => {
                            const container = document.getElementById("dynamicFiltersContainer");
                            const row = document.createElement("div");
                            row.className = "row dynamic-filter-row mb-2 align-items-center";
                            row.innerHTML = `
                <div class="col-4 col-sm-4 col-md-5">
                  <select class="form-select form-select-sm filter-column">
                    <option value="" disabled>Select column</option>
                  </select>
                </div>
                <div class="col-6 col-sm-6 col-md-5 filter-input-container"></div>
                <div class="col-2 col-sm-2 col-md-2 text-end">
                  <button type="button" class="btn btn-danger btn-sm remove-filter">X</button>
                </div>
              `;
                            const select = row.querySelector(".filter-column");
                            select.innerHTML += nodesColumns.map(col => `<option value="${escapeHTML(col)}">${escapeHTML(col)}</option>`).join('');
                            select.value = filter.column;
                            updateFilterInput(row, filter.column);
                            if (filter.type === "number") {
                                const boolSelect = row.querySelector(".filter-boolean");
                                if (boolSelect) {
                                    boolSelect.value = filter.value || "";
                                } else {
                                    row.querySelector(".filter-min").value = filter.min || "";
                                    row.querySelector(".filter-max").value = filter.max || "";
                                }
                            } else {
                                const selectEl = row.querySelector(".filter-values");
                                if (filter.values) {
                                    Array.from(selectEl.options).forEach(option => {
                                        if (filter.values.includes(option.value)) {
                                            option.selected = true;
                                        }
                                    });
                                }
                                row.querySelector(".filter-exclude").checked = filter.exclude || false;
                            }
                            row.querySelector(".remove-filter").addEventListener("click", () => row.remove());
                            container.appendChild(row);
                        });
                    }
                } catch (e) {
                    console.error("Error loading share state:", e);
                }
            }
        }

        // Apply dynamic filters and update DataTables.
        function applyFilters() {
            getSelectedGenesFromBox();
            let base = nodesData;
            if (selectedGenes.length) {
                const matched = nodesData.filter(n =>
                    selectedGenes.some(q => n.gene_name.toLowerCase().includes(q.toLowerCase()) && n.gene_name.length >= q.length)
                );
                const ids = new Set(matched.map(n => n.id));
                edgesData.forEach(e => {
                    if (ids.has(e.source) || ids.has(e.target)) {
                        ids.add(e.source);
                        ids.add(e.target);
                    }
                });
                base = nodesData.filter(n => ids.has(n.id));
            }
            let filteredNodes = base; // No static filters.

            // Apply dynamic filters.
            const dynamicFilters = document.querySelectorAll(".dynamic-filter-row");
            dynamicFilters.forEach(filterRow => {
                const col = filterRow.querySelector(".filter-column").value;
                if (!col) return;
                const type = nodesColumnTypes[col];
                if (type === "number") {
                    const boolSelect = filterRow.querySelector(".filter-boolean");
                    if (boolSelect) {
                        const selectedValue = boolSelect.value;
                        if (selectedValue !== "") {
                            filteredNodes = filteredNodes.filter(n => n[col] === selectedValue);
                        }
                    } else {
                        const minInput = filterRow.querySelector(".filter-min").value;
                        const maxInput = filterRow.querySelector(".filter-max").value;
                        filteredNodes = filteredNodes.filter(n => {
                            const val = parseFloat(n[col]);
                            if (minInput !== "" && !isNaN(parseFloat(minInput)) && val < parseFloat(minInput)) return false;
                            if (maxInput !== "" && !isNaN(parseFloat(maxInput)) && val > parseFloat(maxInput)) return false;
                            return true;
                        });
                    }
                } else {
                    const selectEl = filterRow.querySelector(".filter-values");
                    const selectedValues = Array.from(selectEl.selectedOptions).map(opt => opt.value);
                    if (selectedValues.length > 0) {
                        const exclude = filterRow.querySelector(".filter-exclude").checked;
                        filteredNodes = filteredNodes.filter(n => {
                            return exclude ? !selectedValues.includes(n[col]) : selectedValues.includes(n[col]);
                        });
                    }
                }
            });

            const ids = new Set(filteredNodes.map(n => n.id));
            const filteredEdges = edgesData.filter(e => ids.has(e.source) && ids.has(e.target));

            $('#nodesTable').DataTable().clear().rows.add(filteredNodes).draw();
            $('#edgesTable').DataTable().clear().rows.add(filteredEdges).draw();

            const statsBox = document.getElementById("statsBox");
            statsBox.classList.remove("d-none");
            statsBox.innerHTML = `${filteredNodes.length} nodes, ${filteredEdges.length} edges, ${new Set(filteredNodes.map(n => n.component_id)).size} component(s).`;

            return { filteredNodes, filteredEdges };
        }

        function showGraph(nodes, edges) {
            const container = document.getElementById("graphContainer");
            container.style.display = "block";
            const graph = {
                nodes: nodes.map(n => {
                    const label = n.gene_name && n.gene_name !== "unknown" ? `${n.gene_name} (${n.id})` : n.id;
                    return { id: n.id, label: label, title: `Gene: ${n.gene_name}\nID: ${n.id}` };
                }),
                edges: edges.map(e => ({ from: e.source, to: e.target }))
            };
            new vis.Network(container, graph, { physics: { stabilization: true } });
        }

        function downloadZip(nodes, edges) {
            const zip = new JSZip();
            zip.file("filtered_nodes.tsv", toTSV(nodes));
            zip.file("filtered_edges.tsv", toTSV(edges));
            zip.file("filtered_nodes.bed", toBED(nodes));

            // Compute full component files.
            const adj = {};
            nodesData.forEach(n => { adj[n.id] = []; });
            edgesData.forEach(e => {
                if (adj[e.source] && adj[e.target]) {
                    adj[e.source].push(e.target);
                    adj[e.target].push(e.source);
                }
            });
            const filteredIds = new Set(nodes.map(n => n.id));
            const visited = new Set();
            const fullComponentIds = new Set();
            function dfs(nodeId) {
                if (visited.has(nodeId)) return;
                visited.add(nodeId);
                fullComponentIds.add(nodeId);
                (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
            }
            filteredIds.forEach(id => { if (!visited.has(id)) dfs(id); });
            const fullComponentNodes = nodesData.filter(n => fullComponentIds.has(n.id));
            const fullComponentEdges = edgesData.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
            zip.file("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
            zip.file("filtered_nodes_full_component.bed", toBED(fullComponentNodes));

            zip.generateAsync({ type: "blob" }).then(file => {
                downloadFile(file, "filtered_data.zip", "application/zip");
            });
        }

        // Download individual files.
        function downloadIndividualFile(filename, content) {
            const prefix = document.getElementById("filePrefix").value || "";
            downloadFile(content, prefix + filename, "text/plain");
        }

        document.getElementById("downloadNodesTsv").addEventListener("click", () => {
            const { filteredNodes } = applyFilters();
            downloadIndividualFile("filtered_nodes.tsv", toTSV(filteredNodes));
        });
        document.getElementById("downloadEdgesTsv").addEventListener("click", () => {
            const { filteredEdges } = applyFilters();
            downloadIndividualFile("filtered_edges.tsv", toTSV(filteredEdges));
        });
        document.getElementById("downloadNodesBed").addEventListener("click", () => {
            const { filteredNodes } = applyFilters();
            downloadIndividualFile("filtered_nodes.bed", toBED(filteredNodes));
        });
        document.getElementById("downloadFullEdgesTsv").addEventListener("click", () => {
            const { filteredNodes } = applyFilters();
            const adj = {};
            nodesData.forEach(n => { adj[n.id] = []; });
            edgesData.forEach(e => {
                if (adj[e.source] && adj[e.target]) {
                    adj[e.source].push(e.target);
                    adj[e.target].push(e.source);
                }
            });
            const filteredIds = new Set(filteredNodes.map(n => n.id));
            const visited = new Set();
            const fullComponentIds = new Set();
            function dfs(nodeId) {
                if (visited.has(nodeId)) return;
                visited.add(nodeId);
                fullComponentIds.add(nodeId);
                (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
            }
            filteredIds.forEach(id => { if (!visited.has(id)) dfs(id); });
            const fullComponentEdges = edgesData.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
            downloadIndividualFile("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
        });
        document.getElementById("downloadFullNodesBed").addEventListener("click", () => {
            const { filteredNodes } = applyFilters();
            const adj = {};
            nodesData.forEach(n => { adj[n.id] = []; });
            edgesData.forEach(e => {
                if (adj[e.source] && adj[e.target]) {
                    adj[e.source].push(e.target);
                    adj[e.target].push(e.source);
                }
            });
            const filteredIds = new Set(filteredNodes.map(n => n.id));
            const visited = new Set();
            const fullComponentIds = new Set();
            function dfs(nodeId) {
                if (visited.has(nodeId)) return;
                visited.add(nodeId);
                fullComponentIds.add(nodeId);
                (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
            }
            filteredIds.forEach(id => { if (!visited.has(id)) dfs(id); });
            const fullComponentNodes = nodesData.filter(n => fullComponentIds.has(n.id));
            downloadIndividualFile("filtered_nodes_full_component.bed", toBED(fullComponentNodes));
        });

        document.getElementById("shareResults").onclick = shareResults;

        // Event listeners for gene input and dynamic filters.
        document.getElementById("geneTags").addEventListener("input", e => {
            const inputText = e.target.innerText || '';
            const latest = inputText.split(",").pop().trim();
            if (latest && latest.length >= 2) {
                autocomplete(latest);
            } else {
                document.getElementById("suggestions").innerHTML = '';
            }
        });

        document.getElementById("addFilter").addEventListener("click", addDynamicFilterRow);

        document.getElementById("applyFilters").onclick = () => {
            applyFilters();
            document.getElementById("graphContainer").style.display = "none";
        };

        document.getElementById("visualizeGraph").onclick = () => {
            const { filteredNodes, filteredEdges } = applyFilters();
            showGraph(filteredNodes, filteredEdges);
        };

        // Load TSV data and restore share state.
        document.addEventListener("DOMContentLoaded", () => {
            loadTSV("nodes_metadata.tsv", (data, cols) => {
                nodesData = data;
                nodesColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    nodesColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                geneList = [...new Set(data.map(d => d.gene_name).filter(g => g !== "unknown"))];
                $('#nodesTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
                loadShareState();
            });
            loadTSV("edges.tsv", (data, cols) => {
                edgesData = data;
                $('#edgesTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
            });
        });
    </script>
</body>

</html>