<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CHM13v2.0 Segmental Duplications Dashboard</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- DataTables Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/datatables.net-bs5/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    <!-- vis-network CSS -->
    <link href="https://cdn.jsdelivr.net/npm/vis-network/styles/vis-network.min.css" rel="stylesheet">
    <!-- LZString for compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
    <style>
        /* Global styles */
        body {
            font-family: 'Roboto', sans-serif;
            background: #f4f7fa;
            overflow-x: hidden;
        }

        header {
            background: linear-gradient(135deg, #007bff, #00c6ff);
            color: #fff;
            padding: 2rem 1rem;
            text-align: center;
        }

        /* Main container card */
        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }

        .tag-input {
            border: 1px solid #ccc;
            padding: 0.5rem;
            min-height: 3rem;
            cursor: text;
            background: #fff;
            border-radius: 4px;
        }

        .tag {
            background: #007bff;
            color: #fff;
            padding: 0.2rem 0.5rem;
            margin: 0.2rem;
            border-radius: 5px;
            display: inline-block;
        }

        .tag-remove {
            margin-left: 5px;
            cursor: pointer;
        }

        .autocomplete-suggestions {
            background: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            z-index: 1000;
            width: 100%;
            border-radius: 4px;
        }

        .autocomplete-suggestion {
            padding: 0.5rem;
            cursor: pointer;
        }

        .autocomplete-suggestion:hover {
            background: #f0f0f0;
        }

        #graphContainer {
            height: 500px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 1rem;
            margin-bottom: 1rem;
            display: none;
        }

        footer {
            text-align: center;
            padding: 1rem;
            border-top: 1px solid #ccc;
            font-size: 0.9rem;
            color: #666;
            margin-top: 2rem;
        }

        .card {
            border: none;
            margin-bottom: 1rem;
        }

        .card-body {
            padding: 1rem 1.5rem;
        }

        .dynamic-filter-row {
            margin-bottom: 0.5rem;
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header>
        <h1>CHM13v2.0 Segmental Duplications Dashboard</h1>
        <p class="lead">Explore, filter segmental duplications.</p>
    </header>

    <!-- Main Content Container -->
    <div class="main-container">
        <!-- Gene Input Section -->
        <div class="mb-4">
            <label class="form-label">Search genes (comma-separated, case-insensitive):</label>
            <div id="geneTags" class="tag-input" contenteditable="true"></div>
            <div id="suggestions" class="autocomplete-suggestions"></div>
            <button type="button" id="loadExample" class="btn btn-info btn-sm mt-2">Load Example Genes</button>
        </div>

        <!-- Dynamic Filters Accordion -->
        <div class="accordion mb-4" id="filterAccordion">
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingNodes">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseNodes" aria-expanded="true" aria-controls="collapseNodes">
                        Nodes Filters
                    </button>
                </h2>
                <div id="collapseNodes" class="accordion-collapse collapse show" aria-labelledby="headingNodes"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="nodesFiltersContainer"></div>
                        <button type="button" id="addNodeFilter" class="btn btn-primary btn-sm mt-2">Add Node
                            Filter</button>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingEdges">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseEdges" aria-expanded="false" aria-controls="collapseEdges">
                        Edges Filters
                    </button>
                </h2>
                <div id="collapseEdges" class="accordion-collapse collapse" aria-labelledby="headingEdges"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="edgesFiltersContainer"></div>
                        <button type="button" id="addEdgeFilter" class="btn btn-primary btn-sm mt-2">Add Edge
                            Filter</button>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingComponents">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseComponents" aria-expanded="false" aria-controls="collapseComponents">
                        Components Filters
                    </button>
                </h2>
                <div id="collapseComponents" class="accordion-collapse collapse" aria-labelledby="headingComponents"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="componentsFiltersContainer"></div>
                        <button type="button" id="addComponentFilter" class="btn btn-primary btn-sm mt-2">Add Component
                            Filter</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="row mb-4 g-2">
            <div class="col-auto">
                <button type="button" id="applyFilters" class="btn btn-secondary">Apply Filters</button>
            </div>
            <div class="col-auto">
                <button type="button" id="visualizeGraph" class="btn btn-warning">üï∏ Visualize Graph</button>
            </div>
            <div class="col-auto">
                <button type="button" id="downloadZip" class="btn btn-success">‚¨áÔ∏è Download ZIP</button>
            </div>
            <div class="col-auto">
                <button type="button" id="shareResults" class="btn btn-info">Share Results</button>
            </div>
            <div class="col-auto d-flex align-items-center">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="removeIsolatedNodes">
                    <label class="form-check-label" for="removeIsolatedNodes">Remove isolated nodes</label>
                </div>
            </div>
        </div>

        <!-- File Downloads Section -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="mb-2">
                    <label for="filePrefix" class="form-label">File Prefix (optional):</label>
                    <input type="text" class="form-control form-control-sm" id="filePrefix"
                        placeholder="e.g. myResults_">
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <button type="button" id="downloadNodesTsv" class="btn btn-outline-primary btn-sm">Download Nodes
                        TSV</button>
                    <button type="button" id="downloadEdgesTsv" class="btn btn-outline-primary btn-sm">Download Edges
                        TSV</button>
                    <button type="button" id="downloadNodesBed" class="btn btn-outline-primary btn-sm">Download Nodes
                        BED</button>
                    <button type="button" id="downloadFullEdgesTsv" class="btn btn-outline-primary btn-sm">Download Full
                        Component Edges TSV</button>
                    <button type="button" id="downloadFullNodesBed" class="btn btn-outline-primary btn-sm">Download Full
                        Component Nodes BED</button>
                    <!-- New buttons -->
                    <button type="button" id="downloadComponentsTsv" class="btn btn-outline-primary btn-sm">Download
                        Filtered Components TSV</button>
                    <button type="button" id="downloadComponentsZip" class="btn btn-outline-primary btn-sm">Download
                        Separated Components ZIP</button>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div id="statsBox" class="alert alert-info d-none mb-4" style="padding: 0.5rem;"></div>

        <!-- Data Tables -->
        <h6 class="mb-2">üìç Filtered Nodes</h6>
        <div class="table-responsive mb-4">
            <table id="nodesTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>
        <h6 class="mb-2">üìä Filtered Components</h6>
        <div class="table-responsive mb-4">
            <table id="componentsTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>

        <!-- Graph Container -->
        <div id="graphContainer"></div>
    </div>

    <!-- Node Details Modal -->
    <div class="modal fade" id="nodeDetailsModal" tabindex="-1" aria-labelledby="nodeDetailsModalLabel"
        aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="nodeDetailsModalLabel">Node Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="nodeDetailsContent"></div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        Developed by <a href="https://github.com/mr-eyes/" target="_blank">Mohamed Abuelanin</a> in <a
            href="https://www.dennislab.org/" target="_blank">Megan Dennis lab</a>
    </footer>

    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net/js/dataTables.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net-bs5/js/dataTables.bootstrap5.min.js"></script>
    <!-- Bootstrap Bundle for Modal -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- App Logic -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            // Global data arrays and column definitions.
            let nodesData = [], edgesData = [], componentsData = [];
            let geneList = [], selectedGenes = [];
            let nodesColumns = [], edgesColumns = [], componentsColumns = [];
            let nodesColumnTypes = {}, edgesColumnTypes = {}, componentsColumnTypes = {};

            // Updated toBED: now outputs 4 columns with the 4th as "{chr}:{start}-{end}-{gene_name}"
            function toBED(nodes) {
                return nodes.map(n => {
                    const [chr, rng] = n.id.split(":");
                    const [s, e] = rng.split("-");
                    const gene = n.gene_name || "unknown";
                    const name = `${chr}:${s}-${e}-${gene}`;
                    return `${chr}\t${s}\t${e}\t${name}`;
                }).join("\n");
            }

            // Helper: Download file
            function downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                a.click();
            }

            // Convert array of objects to TSV string.
            function toTSV(arr) {
                if (arr.length === 0) return "";
                const keys = Object.keys(arr[0]);
                return [keys.join("\t")].concat(arr.map(obj => keys.map(k => obj[k]).join("\t"))).join("\n");
            }

            // Load TSV files.
            function loadTSV(file, callback) {
                fetch(file).then(r => r.text()).then(t => {
                    const [h, ...lines] = t.trim().split("\n");
                    const keys = h.split("\t");
                    const data = lines.map(line => {
                        const obj = {};
                        line.split("\t").forEach((val, i) => obj[keys[i]] = val);
                        return obj;
                    });
                    callback(data, keys);
                });
            }

            // Escape HTML in strings.
            function escapeHTML(str) {
                if (!str) return '';
                return str.replace(/\\/g, '\\\\')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            // Manage gene tags.
            function updateGeneTags() {
                const box = document.getElementById("geneTags");
                box.innerHTML = "";
                selectedGenes.forEach(g => {
                    const span = document.createElement("span");
                    span.className = "tag";
                    span.textContent = g;
                    span.setAttribute("data-gene", g);
                    const remove = document.createElement("span");
                    remove.className = "tag-remove";
                    remove.innerHTML = "&times;";
                    remove.onclick = () => {
                        selectedGenes = selectedGenes.filter(x => x !== g);
                        updateGeneTags();
                    };
                    span.appendChild(remove);
                    box.appendChild(span);
                    box.appendChild(document.createTextNode(" "));
                });
            }

            // Autocomplete for gene names.
            function autocomplete(input) {
                const match = input.toLowerCase();
                const hits = geneList.filter(g => g.toLowerCase().includes(match) && g.length >= input.length).slice(0, 10);
                const box = document.getElementById("suggestions");
                box.innerHTML = hits.map(g => `<div class="autocomplete-suggestion">${g}</div>`).join('');
                document.querySelectorAll('.autocomplete-suggestion').forEach(el => {
                    el.onclick = () => {
                        const gene = el.textContent.trim();
                        if (!selectedGenes.includes(gene)) selectedGenes.push(gene);
                        updateGeneTags();
                        box.innerHTML = '';
                    };
                });
            }

            // Retrieve gene selections from tags.
            function getSelectedGenesFromBox() {
                const spans = document.querySelectorAll("#geneTags span.tag");
                selectedGenes = Array.from(spans).map(span => span.getAttribute("data-gene"));
            }

            document.getElementById("loadExample").addEventListener("click", () => {
                const exampleGenes = ["ARHGAP11A", "CD8B", "DUSP22", "FAM72A", "GPR89A", "HYDIN", "PDZK1", "ROCK1", "SRGAP2"];
                selectedGenes = exampleGenes;
                updateGeneTags();
            });

            // Generic function to add a dynamic filter row into a container.
            function addDynamicFilterRow(container, columns, colTypes) {
                const row = document.createElement("div");
                row.className = "row dynamic-filter-row align-items-center";
                row.innerHTML = `
          <div class="col-4 col-sm-4 col-md-5">
            <select class="form-select form-select-sm filter-column">
              <option value="" disabled selected>Select column</option>
            </select>
          </div>
          <div class="col-6 col-sm-6 col-md-5 filter-input-container">
            <!-- Dynamic input will appear here -->
          </div>
          <div class="col-2 col-sm-2 col-md-2 text-end">
            <button type="button" class="btn btn-danger btn-sm remove-filter">X</button>
          </div>
        `;
                const select = row.querySelector(".filter-column");
                select.innerHTML += columns.map(col => `<option value="${escapeHTML(col)}">${escapeHTML(col)}</option>`).join('');
                select.addEventListener("change", function () {
                    updateFilterInputRow(row, this.value, colTypes, getDataByType(container));
                });
                row.querySelector(".remove-filter").addEventListener("click", () => row.remove());
                container.appendChild(row);
            }

            // Helper: get data array based on container (nodes, edges, or components)
            function getDataByType(container) {
                if (container.id === "nodesFiltersContainer") return nodesData;
                if (container.id === "edgesFiltersContainer") return edgesData;
                if (container.id === "componentsFiltersContainer") return componentsData;
                return [];
            }

            // Update dynamic filter input based on column type.
            function updateFilterInputRow(filterRow, column, colTypes, data) {
                const container = filterRow.querySelector(".filter-input-container");
                const colType = colTypes[column];
                if (colType === "number") {
                    const uniqueValues = [...new Set(data.map(n => n[column]))];
                    const isBoolean = uniqueValues.length === 2 && uniqueValues.includes("0") && uniqueValues.includes("1");
                    if (isBoolean) {
                        container.innerHTML = `
              <select class="form-select form-select-sm filter-boolean">
                <option value="" selected>Select</option>
                <option value="1">True</option>
                <option value="0">False</option>
              </select>
            `;
                    } else {
                        container.innerHTML = `
              <div class="input-group input-group-sm">
                <span class="input-group-text">Min</span>
                <input type="number" class="form-control filter-min" placeholder="Min">
                <span class="input-group-text">Max</span>
                <input type="number" class="form-control filter-max" placeholder="Max">
              </div>
            `;
                    }
                } else {
                    const uniqueValues = [...new Set(data.map(n => n[column]))].sort();
                    const optionsHTML = uniqueValues.map(v => `<option value="${escapeHTML(v)}">${escapeHTML(v)}</option>`).join('');
                    container.innerHTML = `
            <select multiple class="form-select form-select-sm filter-values" size="3">
              ${optionsHTML}
            </select>
            <div class="form-check mt-1">
              <input class="form-check-input filter-exclude" type="checkbox" id="exclude-${column}">
              <label class="form-check-label" for="exclude-${column}" style="font-size: 0.85rem;">Exclude</label>
            </div>
          `;
                }
            }

            // Get filters from a given container.
            function getFiltersFromContainer(container, colTypes) {
                const filters = [];
                container.querySelectorAll(".dynamic-filter-row").forEach(row => {
                    const col = row.querySelector(".filter-column").value;
                    if (!col) return;
                    const filter = { column: col, type: colTypes[col] };
                    if (filter.type === "number") {
                        const boolSelect = row.querySelector(".filter-boolean");
                        if (boolSelect) {
                            filter.value = boolSelect.value;
                        } else {
                            filter.min = row.querySelector(".filter-min").value;
                            filter.max = row.querySelector(".filter-max").value;
                        }
                    } else {
                        const selectEl = row.querySelector(".filter-values");
                        filter.values = Array.from(selectEl.selectedOptions).map(opt => opt.value);
                        filter.exclude = row.querySelector(".filter-exclude").checked;
                    }
                    filters.push(filter);
                });
                return filters;
            }

            // Check if container has any filters.
            function containerHasFilters(container) {
                return container.querySelectorAll(".dynamic-filter-row").length > 0;
            }

            // Build share state from gene selection and all dynamic filters.
            function getShareState() {
                const state = {};
                state.genes = selectedGenes;
                state.nodeFilters = getFiltersFromContainer(document.getElementById("nodesFiltersContainer"), nodesColumnTypes);
                state.edgeFilters = getFiltersFromContainer(document.getElementById("edgesFiltersContainer"), edgesColumnTypes);
                state.componentFilters = getFiltersFromContainer(document.getElementById("componentsFiltersContainer"), componentsColumnTypes);
                state.removeIsolated = document.getElementById("removeIsolatedNodes").checked;
                return state;
            }

            // Update URL with compressed share state and copy to clipboard.
            function shareResults() {
                const state = getShareState();
                const stateStr = LZString.compressToEncodedURIComponent(JSON.stringify(state));
                const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?shareState=" + stateStr;
                window.history.pushState({ path: newUrl }, '', newUrl);
                navigator.clipboard.writeText(newUrl).then(() => {
                    const shareBtn = document.getElementById("shareResults");
                    shareBtn.textContent = "Link Copied!";
                    setTimeout(() => { shareBtn.textContent = "Share Results"; }, 2000);
                }).catch(err => { console.error("Could not copy link: ", err); });
            }

            // Restore share state from URL if present.
            function loadShareState() {
                const params = new URLSearchParams(window.location.search);
                if (params.has("shareState")) {
                    try {
                        const compressedState = params.get("shareState");
                        const state = JSON.parse(LZString.decompressFromEncodedURIComponent(compressedState));
                        if (state.genes) {
                            selectedGenes = state.genes;
                            updateGeneTags();
                        }
                        if (state.nodeFilters) {
                            state.nodeFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("nodesFiltersContainer"), nodesColumns, nodesColumnTypes);
                                const row = document.querySelector("#nodesFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, nodesColumnTypes, nodesData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        if (state.edgeFilters) {
                            state.edgeFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("edgesFiltersContainer"), edgesColumns, edgesColumnTypes);
                                const row = document.querySelector("#edgesFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, edgesColumnTypes, edgesData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        if (state.componentFilters) {
                            state.componentFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("componentsFiltersContainer"), componentsColumns, componentsColumnTypes);
                                const row = document.querySelector("#componentsFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, componentsColumnTypes, componentsData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        // Restore removal checkbox state.
                        if (state.hasOwnProperty("removeIsolated")) {
                            document.getElementById("removeIsolatedNodes").checked = state.removeIsolated;
                        }
                        // After loading the share state, auto apply filters and visualize.
                        setTimeout(() => {
                            const results = applyFiltersAll();
                            if (results.finalNodes.length > 1000) {
                                alert("Visualization aborted: More than 1000 nodes to display.");
                            } else {
                                showGraph(results.finalNodes, results.finalEdges);
                            }
                        }, 500);
                    } catch (e) {
                        console.error("Error loading share state:", e);
                    }
                }
            }

            // Generic function to apply filters on data given a container and column types.
            function applyFiltersOnData(data, container, colTypes, extraFilterFn) {
                let filtered = data;
                if (extraFilterFn) {
                    filtered = filtered.filter(extraFilterFn);
                }
                if (containerHasFilters(container)) {
                    const filters = getFiltersFromContainer(container, colTypes);
                    filters.forEach(filter => {
                        if (filter.type === "number") {
                            if (filter.value !== undefined) {
                                filtered = filtered.filter(d => d[filter.column] === filter.value);
                            } else {
                                filtered = filtered.filter(d => {
                                    const val = parseFloat(d[filter.column]);
                                    if (filter.min !== "" && !isNaN(parseFloat(filter.min)) && val < parseFloat(filter.min)) return false;
                                    if (filter.max !== "" && !isNaN(parseFloat(filter.max)) && val > parseFloat(filter.max)) return false;
                                    return true;
                                });
                            }
                        } else {
                            filtered = filtered.filter(d => {
                                const include = filter.values.includes(d[filter.column]);
                                return filter.exclude ? !include : include;
                            });
                        }
                    });
                }
                return filtered;
            }

            // Apply all filters and update views.
            function applyFiltersAll() {
                // Step 1: Apply node dynamic filters (ignoring gene query)
                let allowedNodes = applyFiltersOnData(nodesData, document.getElementById("nodesFiltersContainer"), nodesColumnTypes);
                const allowedIds = new Set(allowedNodes.map(n => n.id));
                // Apply edge filters on edges among allowed nodes.
                let allowedEdges = applyFiltersOnData(edgesData, document.getElementById("edgesFiltersContainer"), edgesColumnTypes)
                    .filter(e => allowedIds.has(e.source) && allowedIds.has(e.target));
                // If gene query exists, select allowed nodes that match gene query and then compute connected components.
                let finalNodeIds = new Set();
                if (selectedGenes.length > 0) {
                    const geneMatched = allowedNodes.filter(n => selectedGenes.some(q => n.gene_name.toLowerCase().includes(q.toLowerCase())));
                    const geneMatchedIds = new Set(geneMatched.map(n => n.id));
                    // Build induced graph (adjacency list) on allowed nodes using allowedEdges.
                    const adj = {};
                    allowedNodes.forEach(n => { adj[n.id] = []; });
                    allowedEdges.forEach(e => {
                        if (adj[e.source]) adj[e.source].push(e.target);
                        if (adj[e.target]) adj[e.target].push(e.source);
                    });
                    const visited = new Set();
                    function dfs(nodeId, component) {
                        visited.add(nodeId);
                        component.push(nodeId);
                        (adj[nodeId] || []).forEach(neighbor => {
                            if (!visited.has(neighbor)) {
                                dfs(neighbor, component);
                            }
                        });
                    }
                    const components = [];
                    allowedNodes.forEach(n => {
                        if (!visited.has(n.id)) {
                            let comp = [];
                            dfs(n.id, comp);
                            components.push(comp);
                        }
                    });
                    // Keep entire components that contain at least one gene-matched node.
                    components.forEach(comp => {
                        if (comp.some(id => geneMatchedIds.has(id))) {
                            comp.forEach(id => finalNodeIds.add(id));
                        }
                    });
                } else {
                    allowedNodes.forEach(n => finalNodeIds.add(n.id));
                }
                // Further restrict by component filters if any.
                const filteredComponents = applyFiltersOnData(componentsData, document.getElementById("componentsFiltersContainer"), componentsColumnTypes);
                // Update each component: keep only node_ids present in finalNodeIds.
                let finalComponents = filteredComponents.map(comp => {
                    let new_ids = comp.node_ids.split(";").filter(id => finalNodeIds.has(id));
                    let newComp = Object.assign({}, comp);
                    newComp.node_ids = new_ids.join(";");
                    return newComp;
                }).filter(comp => comp.node_ids.trim() !== "");
                let finalNodes = nodesData.filter(n => finalNodeIds.has(n.id));
                let finalEdges = allowedEdges.filter(e => finalNodeIds.has(e.source) && finalNodeIds.has(e.target));

                // Option: Remove isolated nodes (not connected to any edge).
                if (document.getElementById("removeIsolatedNodes").checked) {
                    const connectedIds = new Set();
                    finalEdges.forEach(e => {
                        connectedIds.add(e.source);
                        connectedIds.add(e.target);
                    });
                    finalNodes = finalNodes.filter(n => connectedIds.has(n.id));
                    finalEdges = finalEdges.filter(e => connectedIds.has(e.source) && connectedIds.has(e.target));
                    // Also update finalComponents to only include nodes that are still present.
                    finalComponents = finalComponents.map(comp => {
                        let new_ids = comp.node_ids.split(";").filter(id => finalNodes.some(n => n.id === id));
                        let newComp = Object.assign({}, comp);
                        newComp.node_ids = new_ids.join(";");
                        return newComp;
                    }).filter(comp => comp.node_ids.trim() !== "");
                }

                // Update DataTables.
                $('#nodesTable').DataTable().clear().rows.add(finalNodes).draw();
                $('#componentsTable').DataTable().clear().rows.add(finalComponents).draw();

                // Compute unique genes.
                const uniqueGenes = new Set(finalNodes.map(n => n.gene_name).filter(g => g && g.toLowerCase() !== "unknown"));

                const statsBox = document.getElementById("statsBox");
                statsBox.classList.remove("d-none");
                statsBox.innerHTML = `${finalNodes.length} nodes, ${finalEdges.length} edges, ${finalComponents.length} component(s), ${uniqueGenes.size} unique gene(s).`;

                return { finalNodes, finalEdges, finalComponents };
            }

            // Enhanced interactive graph visualization.
            function showGraph(nodes, edges) {
                if (nodes.length > 1000) {
                    alert("Visualization aborted: More than 1000 nodes to display.");
                    return;
                }
                const container = document.getElementById("graphContainer");
                container.style.display = "block";
                const graphData = {
                    nodes: nodes.map(n => {
                        const label = n.gene_name && n.gene_name !== "unknown" ? `${n.gene_name} (${n.id})` : n.id;
                        return { id: n.id, label: label, title: `Gene: ${n.gene_name}\nID: ${n.id}` };
                    }),
                    edges: edges.map(e => ({
                        from: e.source,
                        to: e.target,
                        title: Object.entries(e).map(([k, v]) => `${k}: ${v}`).join("\n")
                    }))
                };
                const options = {
                    physics: {
                        stabilization: true,
                        barnesHut: {
                            gravitationalConstant: -20000,
                            springLength: 250
                        }
                    },
                    interaction: {
                        tooltipDelay: 200,
                        hover: true
                    },
                    nodes: {
                        shape: 'dot',
                        size: 10,
                        font: { size: 14, color: '#343a40' }
                    },
                    edges: {
                        width: 2
                    }
                };
                const network = new vis.Network(container, graphData, options);
                network.on("click", function (params) {
                    if (params.nodes.length > 0) {
                        let nodeId = params.nodes[0];
                        let nodeData = nodes.find(n => n.id === nodeId);
                        if (nodeData) {
                            document.getElementById("nodeDetailsContent").innerHTML = `<pre>${JSON.stringify(nodeData, null, 2)}</pre>`;
                            var modal = new bootstrap.Modal(document.getElementById('nodeDetailsModal'));
                            modal.show();
                        }
                    }
                });
            }

            // Download ZIP with all filtered files.
            function downloadZip(finalNodes, finalEdges) {
                const zip = new JSZip();
                zip.file("filtered_nodes.tsv", toTSV(finalNodes));
                zip.file("filtered_edges.tsv", toTSV(finalEdges));
                zip.file("filtered_nodes.bed", toBED(finalNodes));

                // Compute full connected components on the final filtered set.
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentNodes = finalNodes.filter(n => fullComponentIds.has(n.id));
                const fullComponentEdges = finalEdges.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
                zip.file("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
                zip.file("filtered_nodes_full_component.bed", toBED(fullComponentNodes));

                zip.generateAsync({ type: "blob" }).then(file => {
                    const prefix = document.getElementById("filePrefix").value || "";
                    downloadFile(file, prefix + "filtered_data.zip", "application/zip");
                });
            }

            // Download individual files.
            function downloadIndividualFile(filename, content) {
                const prefix = document.getElementById("filePrefix").value || "";
                downloadFile(content, prefix + filename, "text/plain");
            }

            // New: Download filtered components as TSV.
            function downloadComponentsTSV(finalComponents) {
                downloadIndividualFile("filtered_components.tsv", toTSV(finalComponents));
            }

            // New: Download separate components ZIP (each component as a separate BED file).
            function downloadComponentsZip(finalComponents, finalNodes) {
                const zip = new JSZip();
                finalComponents.forEach(comp => {
                    const compNodeIds = comp.node_ids.split(";");
                    const compNodes = finalNodes.filter(n => compNodeIds.includes(n.id));
                    zip.file(`component_${comp.component_id}.bed`, toBED(compNodes));
                });
                zip.generateAsync({ type: "blob" }).then(file => {
                    const prefix = document.getElementById("filePrefix").value || "";
                    downloadFile(file, prefix + "separated_components.zip", "application/zip");
                });
            }

            // Set up event listeners for downloads.
            document.getElementById("downloadZip").addEventListener("click", () => {
                const { finalNodes, finalEdges, finalComponents } = applyFiltersAll();
                downloadZip(finalNodes, finalEdges);
            });
            document.getElementById("downloadNodesTsv").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                downloadIndividualFile("filtered_nodes.tsv", toTSV(finalNodes));
            });
            document.getElementById("downloadEdgesTsv").addEventListener("click", () => {
                const { finalEdges } = applyFiltersAll();
                downloadIndividualFile("filtered_edges.tsv", toTSV(finalEdges));
            });
            document.getElementById("downloadNodesBed").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                downloadIndividualFile("filtered_nodes.bed", toBED(finalNodes));
            });
            document.getElementById("downloadFullEdgesTsv").addEventListener("click", () => {
                const { finalNodes, finalEdges } = applyFiltersAll();
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentEdges = finalEdges.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
                downloadIndividualFile("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
            });
            document.getElementById("downloadFullNodesBed").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                const { finalEdges } = applyFiltersAll();
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentNodes = finalNodes.filter(n => fullComponentIds.has(n.id));
                downloadIndividualFile("filtered_nodes_full_component.bed", toBED(fullComponentNodes));
            });
            document.getElementById("downloadComponentsTsv").addEventListener("click", () => {
                const { finalComponents } = applyFiltersAll();
                downloadComponentsTSV(finalComponents);
            });
            document.getElementById("downloadComponentsZip").addEventListener("click", () => {
                const { finalComponents, finalNodes } = applyFiltersAll();
                downloadComponentsZip(finalComponents, finalNodes);
            });

            document.getElementById("shareResults").onclick = shareResults;
            document.getElementById("applyFilters").onclick = () => {
                applyFiltersAll();
                document.getElementById("graphContainer").style.display = "none";
            };
            document.getElementById("visualizeGraph").onclick = () => {
                const { finalNodes, finalEdges } = applyFiltersAll();
                showGraph(finalNodes, finalEdges);
            };

            // Set up Add Filter buttons for each filter container.
            document.getElementById("addNodeFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("nodesFiltersContainer"), nodesColumns, nodesColumnTypes);
            });
            document.getElementById("addEdgeFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("edgesFiltersContainer"), edgesColumns, edgesColumnTypes);
            });
            document.getElementById("addComponentFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("componentsFiltersContainer"), componentsColumns, componentsColumnTypes);
            });

            // Initialize DataTables.
            $('#nodesTable').DataTable({ data: [], columns: [] });
            $('#componentsTable').DataTable({ data: [], columns: [] });

            // Load TSV Data and restore share state.
            loadTSV("nodes_metadata.tsv", (data, cols) => {
                nodesData = data;
                nodesColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    nodesColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                geneList = [...new Set(data.map(d => d.gene_name).filter(g => g !== "unknown"))];
                $('#nodesTable').DataTable().destroy();
                $('#nodesTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
                loadShareState();
            });
            loadTSV("edges.tsv", (data, cols) => {
                edgesData = data;
                edgesColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    edgesColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                // Edges table view removed ‚Äì used only for filtering and graph.
            });
            loadTSV("connected_components_summary.tsv", (data, cols) => {
                componentsData = data;
                componentsColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    componentsColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                $('#componentsTable').DataTable().destroy();
                $('#componentsTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
            });
        });
    </script>
</body>

</html>