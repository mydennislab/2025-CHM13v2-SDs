<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CHM13v2.0 Segmental Duplications Dashboard</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- DataTables Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/datatables.net-bs5/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    <!-- vis-network CSS -->
    <link href="https://cdn.jsdelivr.net/npm/vis-network/styles/vis-network.min.css" rel="stylesheet">
    <!-- LZString for compression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
    <style>
        /* Global styles */
        body {
            font-family: 'Roboto', sans-serif;
            background: #f4f7fa;
            overflow-x: hidden;
        }

        header {
            background: linear-gradient(135deg, #007bff, #00c6ff);
            color: #fff;
            padding: 2rem 1rem;
            text-align: center;
        }

        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }

        /* Gene tags input */
        #geneTagsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 3rem;
            background: #fff;
        }

        .tag {
            background: #007bff;
            color: #fff;
            padding: 0.2rem 0.5rem;
            margin: 2px;
            border-radius: 5px;
            display: inline-block;
        }

        .tag-remove {
            margin-left: 5px;
            cursor: pointer;
        }

        #geneInput {
            border: none;
            outline: none;
            flex: 1;
            min-width: 150px;
        }

        .autocomplete-suggestions {
            background: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            position: absolute;
            z-index: 1000;
            width: 100%;
            border-radius: 4px;
        }

        .autocomplete-suggestion {
            padding: 0.5rem;
            cursor: pointer;
        }

        .autocomplete-suggestion:hover {
            background: #f0f0f0;
        }

        footer {
            text-align: center;
            padding: 1rem;
            border-top: 1px solid #ccc;
            font-size: 0.9rem;
            color: #666;
            margin-top: 2rem;
        }

        .card {
            border: none;
            margin-bottom: 1rem;
        }

        .card-body {
            padding: 1rem 1.5rem;
        }

        .dynamic-filter-row {
            margin-bottom: 0.5rem;
        }

        /* Tooltip for copying node name */
        #copyTooltip {
            position: absolute;
            display: none;
            background: #fff;
            border: 1px solid #ccc;
            padding: 5px;
            cursor: pointer;
            z-index: 3000;
            font-size: 0.9rem;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header>
        <h1>CHM13v2.0 Segmental Duplications Dashboard</h1>
        <p class="lead">Explore, filter segmental duplications.</p>
    </header>
    <!-- Main Content Container -->
    <div class="main-container">
        <!-- Gene Input Section -->
        <div class="mb-4">
            <label class="form-label">Search genes (comma-separated, case-insensitive):</label>
            <div id="geneTagsContainer">
                <input type="text" id="geneInput" placeholder="Type gene name and press Enter">
            </div>
            <div id="suggestions" class="autocomplete-suggestions"></div>
            <button type="button" id="loadExample" class="btn btn-info btn-sm mt-2">Load Example Genes</button>
        </div>

        <!-- Region Search Section -->
        <div class="mb-4">
            <label class="form-label">Search by genomic regions:</label>
            <div class="input-group mb-2">
                <input type="text" id="regionInput" class="form-control" placeholder="e.g., chr1:1000-2000 or chr2:3000-4000">
                <button class="btn btn-primary" type="button" id="addRegionButton">Add Region</button>
            </div>
            <div id="regionTagsContainer" class="d-flex flex-wrap gap-1 border p-2 rounded mb-2" style="min-height: 40px;"></div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="enableRegionOverlapSearch" checked>
                <label class="form-check-label" for="enableRegionOverlapSearch">
                    Find overlapping regions (uncheck to find exact matches)
                </label>
            </div>
            <div class="form-check mb-2">
                <input class="form-check-input" type="checkbox" id="includeParalogRegions">
                <label class="form-check-label" for="includeParalogRegions">
                    Include paralog regions (find any region connected to matching regions)
                </label>
                <i class="bi bi-info-circle ms-1" data-bs-toggle="tooltip" title="Identifies and includes paralogous duplications of the specified regions"></i>
            </div>
            <button type="button" id="clearRegionSearch" class="btn btn-outline-secondary btn-sm">Clear Regions</button>
        </div>

        <!-- Dynamic Filters Accordion -->
        <div class="accordion mb-4" id="filterAccordion">
            <!-- Nodes Filters -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingNodes">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseNodes" aria-expanded="true" aria-controls="collapseNodes">
                        Nodes Filters
                    </button>
                </h2>
                <div id="collapseNodes" class="accordion-collapse collapse show" aria-labelledby="headingNodes"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="nodesFiltersContainer"></div>
                        <button type="button" id="addNodeFilter" class="btn btn-primary btn-sm mt-2">Add Node
                            Filter</button>
                    </div>
                </div>
            </div>
            <!-- Edges Filters -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingEdges">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseEdges" aria-expanded="false" aria-controls="collapseEdges">
                        Edges Filters
                    </button>
                </h2>
                <div id="collapseEdges" class="accordion-collapse collapse" aria-labelledby="headingEdges"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="edgesFiltersContainer"></div>
                        <button type="button" id="addEdgeFilter" class="btn btn-primary btn-sm mt-2">Add Edge
                            Filter</button>
                    </div>
                </div>
            </div>
            <!-- Components Filters -->
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingComponents">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseComponents" aria-expanded="false" aria-controls="collapseComponents">
                        Components Filters
                    </button>
                </h2>
                <div id="collapseComponents" class="accordion-collapse collapse" aria-labelledby="headingComponents"
                    data-bs-parent="#filterAccordion">
                    <div class="accordion-body">
                        <div id="componentsFiltersContainer"></div>
                        <button type="button" id="addComponentFilter" class="btn btn-primary btn-sm mt-2">Add Component
                            Filter</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Action Buttons -->
        <div class="row mb-4 g-2">
            <div class="col-auto">
                <button type="button" id="applyFilters" class="btn btn-secondary">Apply Filters</button>
            </div>
            <div class="col-auto">
                <button type="button" id="visualizeGraph" class="btn btn-warning">üï∏ Visualize Graph</button>
            </div>
            <div class="col-auto">
                <button type="button" id="downloadZip" class="btn btn-success">‚¨áÔ∏è Download ZIP</button>
            </div>
            <div class="col-auto">
                <button type="button" id="shareResults" class="btn btn-info">Share Results</button>
            </div>
            <div class="col-auto d-flex align-items-center">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="removeIsolatedNodes">
                    <label class="form-check-label" for="removeIsolatedNodes">Remove isolated nodes</label>
                </div>
            </div>
        </div>
        <!-- File Downloads Section -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="mb-2">
                    <label for="filePrefix" class="form-label">File Prefix (optional):</label>
                    <input type="text" class="form-control form-control-sm" id="filePrefix"
                        placeholder="e.g. myResults_">
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <button type="button" id="downloadNodesTsv" class="btn btn-outline-primary btn-sm">Download Nodes
                        TSV</button>
                    <button type="button" id="downloadEdgesTsv" class="btn btn-outline-primary btn-sm">Download Edges
                        TSV</button>
                    <button type="button" id="downloadNodesBed" class="btn btn-outline-primary btn-sm">Download Nodes
                        BED</button>
                    <button type="button" id="downloadFullEdgesTsv" class="btn btn-outline-primary btn-sm">Download Full
                        Component Edges TSV</button>
                    <button type="button" id="downloadFullNodesBed" class="btn btn-outline-primary btn-sm">Download Full
                        Component Nodes BED</button>
                    <button type="button" id="downloadComponentsTsv" class="btn btn-outline-primary btn-sm">Download
                        Filtered Components TSV</button>
                    <button type="button" id="downloadComponentsZip" class="btn btn-outline-primary btn-sm">Download
                        Separated Components ZIP</button>
                </div>
            </div>
        </div>
        <!-- Stats -->
        <div id="statsBox" class="alert alert-info d-none mb-4" style="padding: 0.5rem;"></div>
        <!-- Data Tables -->
        <h6 class="mb-2">üìç Filtered Nodes</h6>
        <div class="table-responsive mb-4">
            <table id="nodesTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>
        <h6 class="mb-2">üìä Filtered Components</h6>
        <div class="table-responsive mb-4">
            <table id="componentsTable" class="table table-striped table-sm" style="width:100%"></table>
        </div>
        <!-- (Inline graph container removed: visualization always in modal) -->
    </div>

    <!-- Graph Modal (Pop-up full-screen visualization) -->
    <div class="modal fade" id="graphFullscreenModal" tabindex="-1" aria-labelledby="graphFullscreenModalLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="graphFullscreenModalLabel">Graph Visualization</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" style="position: relative; padding: 10px;">
                    <!-- The graph configuration panel and graph will be injected here -->
                    <div id="graphFullscreenContainer" style="height: 100%;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Node Details Modal -->
    <div class="modal fade" id="nodeDetailsModal" tabindex="-1" aria-labelledby="nodeDetailsModalLabel"
        aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="nodeDetailsModalLabel">Node Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="nodeDetailsContent"></div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Copy Tooltip for Node Name -->
    <div id="copyTooltip"></div>

    <!-- Footer -->
    <footer>
        Developed by <a href="https://github.com/mr-eyes/" target="_blank">Mohamed Abuelanin</a> in <a
            href="https://www.dennislab.org/" target="_blank">Megan Dennis lab</a>
    </footer>

    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net/js/dataTables.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/datatables.net-bs5/js/dataTables.bootstrap5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <!-- App Logic -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            let nodesData = [], edgesData = [], componentsData = [];
            let geneList = [], selectedGenes = [];
            let selectedRegions = [];  // Array to store selected regions
            let nodesColumns = [], edgesColumns = [], componentsColumns = [];
            let nodesColumnTypes = {}, edgesColumnTypes = {}, componentsColumnTypes = {};

            // Global modal network variables
            let modalNetwork = null;
            let modalNetworkData = { nodes: null, edges: null };

            function toBED(nodes) {
                return nodes.map(n => {
                    const [chr, rng] = n.id.split(":");
                    const [s, e] = rng.split("-");
                    const gene = n.gene_name || "unknown";
                    const name = `${chr}:${s}-${e}_${gene}`;
                    return `${chr}\t${s}\t${e}\t${name}`;
                }).join("\n");
            }

            function downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                a.click();
            }

            function toTSV(arr) {
                if (arr.length === 0) return "";
                const keys = Object.keys(arr[0]);
                return [keys.join("\t")].concat(arr.map(obj => keys.map(k => obj[k]).join("\t"))).join("\n");
            }

            function loadTSV(file, callback) {
                fetch(file).then(r => r.text()).then(t => {
                    const [h, ...lines] = t.trim().split("\n");
                    const keys = h.split("\t");
                    const data = lines.map(line => {
                        const obj = {};
                        line.split("\t").forEach((val, i) => obj[keys[i]] = val);
                        return obj;
                    });
                    callback(data, keys);
                });
            }

            function escapeHTML(str) {
                if (!str) return '';
                return str.replace(/\\/g, '\\\\')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            const geneTagsContainer = document.getElementById("geneTagsContainer");
            const geneInput = document.getElementById("geneInput");

            function updateGeneTags() {
                geneTagsContainer.innerHTML = "";
                selectedGenes.forEach(g => {
                    const span = document.createElement("span");
                    span.className = "tag";
                    span.textContent = g;
                    span.setAttribute("data-gene", g);
                    const remove = document.createElement("span");
                    remove.className = "tag-remove";
                    remove.innerHTML = "&times;";
                    remove.onclick = () => {
                        selectedGenes = selectedGenes.filter(x => x !== g);
                        updateGeneTags();
                    };
                    span.appendChild(remove);
                    geneTagsContainer.appendChild(span);
                });
                geneTagsContainer.appendChild(geneInput);
                geneInput.focus();
            }

            geneInput.addEventListener("keydown", function (e) {
                if (e.key === "Enter") {
                    e.preventDefault();
                    let gene = this.value.trim();
                    if (gene !== "" && !selectedGenes.includes(gene)) {
                        selectedGenes.push(gene);
                        updateGeneTags();
                    }
                    this.value = "";
                    document.getElementById("suggestions").innerHTML = "";
                }
            });

            geneInput.addEventListener("input", function () {
                if (this.value.trim() === "") {
                    document.getElementById("suggestions").innerHTML = "";
                } else {
                    autocomplete(this.value);
                }
            });

            function autocomplete(inputText) {
                const match = inputText.toLowerCase();
                const hits = geneList.filter(g => g.toLowerCase().includes(match) && g.length >= inputText.length).slice(0, 10);
                const suggestionsBox = document.getElementById("suggestions");
                suggestionsBox.innerHTML = hits.map(g => `<div class="autocomplete-suggestion">${g}</div>`).join('');
                document.querySelectorAll('.autocomplete-suggestion').forEach(el => {
                    el.onclick = () => {
                        const gene = el.textContent.trim();
                        if (!selectedGenes.includes(gene)) selectedGenes.push(gene);
                        updateGeneTags();
                        suggestionsBox.innerHTML = "";
                    };
                });
            }

            document.getElementById("loadExample").addEventListener("click", () => {
                const exampleGenes = ["ARHGAP11A", "CD8B", "DUSP22", "FAM72A", "GPR89A", "HYDIN", "PDZK1", "ROCK1", "SRGAP2"];
                selectedGenes = exampleGenes;
                updateGeneTags();
            });

            function addDynamicFilterRow(container, columns, colTypes) {
                const row = document.createElement("div");
                row.className = "row dynamic-filter-row align-items-center";
                row.innerHTML = `
          <div class="col-4 col-sm-4 col-md-5">
            <select class="form-select form-select-sm filter-column">
              <option value="" disabled selected>Select column</option>
            </select>
          </div>
          <div class="col-6 col-sm-6 col-md-5 filter-input-container"></div>
          <div class="col-2 col-sm-2 col-md-2 text-end">
            <button type="button" class="btn btn-danger btn-sm remove-filter">X</button>
          </div>
        `;
                const select = row.querySelector(".filter-column");
                select.innerHTML += columns.map(col => `<option value="${escapeHTML(col)}">${escapeHTML(col)}</option>`).join('');
                select.addEventListener("change", function () {
                    updateFilterInputRow(row, this.value, colTypes, getDataByType(container));
                });
                row.querySelector(".remove-filter").addEventListener("click", () => row.remove());
                container.appendChild(row);
            }

            function getDataByType(container) {
                if (container.id === "nodesFiltersContainer") return nodesData;
                if (container.id === "edgesFiltersContainer") return edgesData;
                if (container.id === "componentsFiltersContainer") return componentsData;
                return [];
            }

            function updateFilterInputRow(filterRow, column, colTypes, data) {
                const container = filterRow.querySelector(".filter-input-container");
                const colType = colTypes[column];
                if (colType === "number") {
                    const uniqueValues = [...new Set(data.map(n => n[column]))];
                    const isBoolean = uniqueValues.length === 2 && uniqueValues.includes("0") && uniqueValues.includes("1");
                    if (isBoolean) {
                        container.innerHTML = `
              <select class="form-select form-select-sm filter-boolean">
                <option value="" selected>Select</option>
                <option value="1">True</option>
                <option value="0">False</option>
              </select>
            `;
                    } else {
                        container.innerHTML = `
              <div class="input-group input-group-sm">
                <span class="input-group-text">Min</span>
                <input type="number" class="form-control filter-min" placeholder="Min">
                <span class="input-group-text">Max</span>
                <input type="number" class="form-control filter-max" placeholder="Max">
              </div>
            `;
                    }
                } else {
                    const uniqueValues = [...new Set(data.map(n => n[column]))].sort();
                    const optionsHTML = uniqueValues.map(v => `<option value="${escapeHTML(v)}">${escapeHTML(v)}</option>`).join('');
                    container.innerHTML = `
            <select multiple class="form-select form-select-sm filter-values" size="3">
              ${optionsHTML}
            </select>
            <div class="form-check mt-1">
              <input class="form-check-input filter-exclude" type="checkbox" id="exclude-${column}">
              <label class="form-check-label" for="exclude-${column}" style="font-size: 0.85rem;">Exclude</label>
            </div>
          `;
                }
            }

            function getFiltersFromContainer(container, colTypes) {
                const filters = [];
                container.querySelectorAll(".dynamic-filter-row").forEach(row => {
                    const col = row.querySelector(".filter-column").value;
                    if (!col) return;
                    const filter = { column: col, type: colTypes[col] };
                    if (filter.type === "number") {
                        const boolSelect = row.querySelector(".filter-boolean");
                        if (boolSelect) {
                            filter.value = boolSelect.value;
                        } else {
                            filter.min = row.querySelector(".filter-min").value;
                            filter.max = row.querySelector(".filter-max").value;
                        }
                    } else {
                        const selectEl = row.querySelector(".filter-values");
                        filter.values = Array.from(selectEl.selectedOptions).map(opt => opt.value);
                        filter.exclude = row.querySelector(".filter-exclude").checked;
                    }
                    filters.push(filter);
                });
                return filters;
            }

            function containerHasFilters(container) {
                return container.querySelectorAll(".dynamic-filter-row").length > 0;
            }

            // Function to parse region string into object with chr, start, end
            function parseRegion(regionStr) {
                try {
                    const match = regionStr.match(/^(chr\w+):(\d+)-(\d+)$/);
                    if (!match) return null;
                    
                    return {
                        chr: match[1],
                        start: parseInt(match[2]),
                        end: parseInt(match[3]),
                        original: regionStr
                    };
                } catch (e) {
                    console.error("Error parsing region:", regionStr, e);
                    return null;
                }
            }

            // Function to check if two regions overlap
            function regionsOverlap(region1, region2) {
                return region1.chr === region2.chr && 
                      region1.start <= region2.end && 
                      region2.start <= region1.end;
            }
            
            // Function to handle region input
            function addRegion(regionStr) {
                const region = parseRegion(regionStr);
                if (!region) {
                    alert("Invalid region format. Please use format 'chr:start-end' (e.g., chr1:1000-2000)");
                    return false;
                }
                
                // Check if region already exists
                if (selectedRegions.some(r => r.original === region.original)) {
                    return false;
                }
                
                selectedRegions.push(region);
                updateRegionTags();
                return true;
            }
            
            // Function to update region tags display
            function updateRegionTags() {
                const container = document.getElementById("regionTagsContainer");
                container.innerHTML = "";
                
                selectedRegions.forEach(region => {
                    const tag = document.createElement("div");
                    tag.className = "badge bg-secondary me-1 mb-1 d-flex align-items-center";
                    tag.innerHTML = `
                        <span>${region.original}</span>
                        <button type="button" class="btn-close btn-close-white ms-1" 
                                aria-label="Remove" style="font-size: 0.5rem;"></button>
                    `;
                    
                    tag.querySelector('.btn-close').addEventListener('click', () => {
                        selectedRegions = selectedRegions.filter(r => r.original !== region.original);
                        updateRegionTags();
                    });
                    
                    container.appendChild(tag);
                });
            }

            // Add event listener for the region input
            document.getElementById("addRegionButton").addEventListener("click", () => {
                const regionInput = document.getElementById("regionInput");
                const regionStr = regionInput.value.trim();
                
                if (regionStr) {
                    if (addRegion(regionStr)) {
                        regionInput.value = ""; // Clear input field
                    }
                }
            });
            
            // Allow Enter key to add a region
            document.getElementById("regionInput").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    document.getElementById("addRegionButton").click();
                }
            });
            
            // Clear all regions
            document.getElementById("clearRegionSearch").addEventListener("click", () => {
                selectedRegions = [];
                updateRegionTags();
            });

            function getShareState() {
                const state = {};
                state.genes = selectedGenes;
                state.regions = selectedRegions;
                state.enableRegionOverlapSearch = document.getElementById("enableRegionOverlapSearch").checked;
                state.includeParalogRegions = document.getElementById("includeParalogRegions").checked;
                state.nodeFilters = getFiltersFromContainer(document.getElementById("nodesFiltersContainer"), nodesColumnTypes);
                state.edgeFilters = getFiltersFromContainer(document.getElementById("edgesFiltersContainer"), edgesColumnTypes);
                state.componentFilters = getFiltersFromContainer(document.getElementById("componentsFiltersContainer"), componentsColumnTypes);
                state.removeIsolated = document.getElementById("removeIsolatedNodes").checked;
                return state;
            }

            function shareResults() {
                const state = getShareState();
                const stateStr = LZString.compressToEncodedURIComponent(JSON.stringify(state));
                const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?shareState=" + stateStr;
                window.history.pushState({ path: newUrl }, '', newUrl);
                navigator.clipboard.writeText(newUrl).then(() => {
                    const shareBtn = document.getElementById("shareResults");
                    shareBtn.textContent = "Link Copied!";
                    setTimeout(() => { shareBtn.textContent = "Share Results"; }, 2000);
                }).catch(err => { console.error("Could not copy link: ", err); });
            }

            function loadShareState() {
                const params = new URLSearchParams(window.location.search);
                if (params.has("shareState")) {
                    try {
                        const compressedState = params.get("shareState");
                        const state = JSON.parse(LZString.decompressFromEncodedURIComponent(compressedState));
                        
                        // Load genes
                        if (state.genes) {
                            selectedGenes = state.genes;
                            updateGeneTags();
                        }
                        
                        // Load regions
                        if (state.regions) {
                            selectedRegions = state.regions;
                            updateRegionTags();
                        }
                        
                        // Load region search mode
                        if (state.hasOwnProperty("enableRegionOverlapSearch")) {
                            document.getElementById("enableRegionOverlapSearch").checked = state.enableRegionOverlapSearch;
                        }
                        
                        // Load paralog search option
                        if (state.hasOwnProperty("includeParalogRegions")) {
                            document.getElementById("includeParalogRegions").checked = state.includeParalogRegions;
                        }
                        
                        // Load filters
                        if (state.nodeFilters) {
                            state.nodeFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("nodesFiltersContainer"), nodesColumns, nodesColumnTypes);
                                const row = document.querySelector("#nodesFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, nodesColumnTypes, nodesData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        if (state.edgeFilters) {
                            state.edgeFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("edgesFiltersContainer"), edgesColumns, edgesColumnTypes);
                                const row = document.querySelector("#edgesFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, edgesColumnTypes, edgesData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        if (state.componentFilters) {
                            state.componentFilters.forEach(filter => {
                                addDynamicFilterRow(document.getElementById("componentsFiltersContainer"), componentsColumns, componentsColumnTypes);
                                const row = document.querySelector("#componentsFiltersContainer .dynamic-filter-row:last-child");
                                if (row) {
                                    const filterCol = row.querySelector(".filter-column");
                                    if (filterCol) filterCol.value = filter.column;
                                    updateFilterInputRow(row, filter.column, componentsColumnTypes, componentsData);
                                    if (filter.type === "number") {
                                        const boolSelect = row.querySelector(".filter-boolean");
                                        if (boolSelect) {
                                            boolSelect.value = filter.value || "";
                                        } else {
                                            const minEl = row.querySelector(".filter-min");
                                            if (minEl) minEl.value = filter.min || "";
                                            const maxEl = row.querySelector(".filter-max");
                                            if (maxEl) maxEl.value = filter.max || "";
                                        }
                                    } else {
                                        const selectEl = row.querySelector(".filter-values");
                                        if (selectEl && filter.values) {
                                            Array.from(selectEl.options).forEach(option => {
                                                if (filter.values.includes(option.value)) option.selected = true;
                                            });
                                        }
                                        const excludeEl = row.querySelector(".filter-exclude");
                                        if (excludeEl) excludeEl.checked = filter.exclude || false;
                                    }
                                }
                            });
                        }
                        if (state.hasOwnProperty("removeIsolated")) {
                            document.getElementById("removeIsolatedNodes").checked = state.removeIsolated;
                        }
                        setTimeout(() => {
                            const results = applyFiltersAll();
                            if (results.finalNodes.length > 1000) {
                                alert("Visualization aborted: More than 1000 nodes to display.");
                            } else {
                                // Automatically show graph modal if share state contains valid nodes
                                showGraphModal(results.finalNodes, results.finalEdges);
                            }
                        }, 500);
                    } catch (e) {
                        console.error("Error loading share state:", e);
                    }
                }
            }

            function applyFiltersOnData(data, container, colTypes, extraFilterFn) {
                let filtered = data;
                if (extraFilterFn) filtered = filtered.filter(extraFilterFn);
                if (containerHasFilters(container)) {
                    const filters = getFiltersFromContainer(container, colTypes);
                    filters.forEach(filter => {
                        if (filter.type === "number") {
                            if (filter.value !== undefined) {
                                filtered = filtered.filter(d => d[filter.column] === filter.value);
                            } else {
                                filtered = filtered.filter(d => {
                                    const val = parseFloat(d[filter.column]);
                                    if (filter.min !== "" && !isNaN(parseFloat(filter.min)) && val < parseFloat(filter.min)) return false;
                                    if (filter.max !== "" && !isNaN(parseFloat(filter.max)) && val > parseFloat(filter.max)) return false;
                                    return true;
                                });
                            }
                        } else {
                            filtered = filtered.filter(d => {
                                const include = filter.values.includes(d[filter.column]);
                                return filter.exclude ? !include : include;
                            });
                        }
                    });
                }
                return filtered;
            }

            function applyFiltersAll() {
                // Start with node filters from filter panel
                let allowedNodes = applyFiltersOnData(nodesData, document.getElementById("nodesFiltersContainer"), nodesColumnTypes);
                
                // Apply region filters if any regions are selected
                if (selectedRegions.length > 0) {
                    const useOverlapSearch = document.getElementById("enableRegionOverlapSearch").checked;
                    const includeParalogs = document.getElementById("includeParalogRegions").checked;
                    
                    // First pass: find nodes that directly match the region criteria
                    const directMatchNodeIds = new Set();
                    
                    allowedNodes = allowedNodes.filter(node => {
                        // Parse node's region
                        const nodeRegion = parseRegion(node.id);
                        if (!nodeRegion) return false;
                        
                        // Check if the node's region matches any of the selected regions
                        const isMatch = selectedRegions.some(selectedRegion => {
                            if (useOverlapSearch) {
                                // Check for overlap
                                return regionsOverlap(nodeRegion, selectedRegion);
                            } else {
                                // Check for exact match
                                return nodeRegion.chr === selectedRegion.chr && 
                                       nodeRegion.start === selectedRegion.start && 
                                       nodeRegion.end === selectedRegion.end;
                            }
                        });
                        
                        // If it's a match, add to direct matches
                        if (isMatch) {
                            directMatchNodeIds.add(node.id);
                        }
                        
                        return isMatch;
                    });
                    
                    // If paralog search is enabled, do a second pass to include connected regions
                    if (includeParalogs && directMatchNodeIds.size > 0) {
                        // Build adjacency list from edges
                        const adjacencyList = {};
                        nodesData.forEach(n => { adjacencyList[n.id] = []; });
                        edgesData.forEach(e => {
                            if (adjacencyList[e.source]) adjacencyList[e.source].push(e.target);
                            if (adjacencyList[e.target]) adjacencyList[e.target].push(e.source);
                        });
                        
                        // Find all nodes directly connected to direct matches
                        const paralogNodeIds = new Set([...directMatchNodeIds]);
                        
                        directMatchNodeIds.forEach(nodeId => {
                            // Add all direct neighbors (paralogs)
                            if (adjacencyList[nodeId]) {
                                adjacencyList[nodeId].forEach(neighbor => {
                                    paralogNodeIds.add(neighbor);
                                });
                            }
                        });
                        
                        // Include paralog nodes
                        allowedNodes = nodesData.filter(n => paralogNodeIds.has(n.id));
                    }
                }
                
                const allowedIds = new Set(allowedNodes.map(n => n.id));
                let allowedEdges = applyFiltersOnData(edgesData, document.getElementById("edgesFiltersContainer"), edgesColumnTypes)
                    .filter(e => allowedIds.has(e.source) && allowedIds.has(e.target));
                
                let finalNodeIds = new Set();
                
                // Apply gene filters if any genes are selected
                if (selectedGenes.length > 0) {
                    const geneMatched = allowedNodes.filter(n => selectedGenes.some(q => n.gene_name.toLowerCase().includes(q.toLowerCase())));
                    const geneMatchedIds = new Set(geneMatched.map(n => n.id));
                    const adj = {};
                    allowedNodes.forEach(n => { adj[n.id] = []; });
                    allowedEdges.forEach(e => {
                        if (adj[e.source]) adj[e.source].push(e.target);
                        if (adj[e.target]) adj[e.target].push(e.source);
                    });
                    const visited = new Set();
                    function dfs(nodeId, component) {
                        visited.add(nodeId);
                        component.push(nodeId);
                        (adj[nodeId] || []).forEach(neighbor => {
                            if (!visited.has(neighbor)) dfs(neighbor, component);
                        });
                    }
                    const components = [];
                    allowedNodes.forEach(n => {
                        if (!visited.has(n.id)) {
                            let comp = [];
                            dfs(n.id, comp);
                            components.push(comp);
                        }
                    });
                    components.forEach(comp => {
                        if (comp.some(id => geneMatchedIds.has(id))) {
                            comp.forEach(id => finalNodeIds.add(id));
                        }
                    });
                } else {
                    allowedNodes.forEach(n => finalNodeIds.add(n.id));
                }
                const filteredComponents = applyFiltersOnData(componentsData, document.getElementById("componentsFiltersContainer"), componentsColumnTypes);
                let finalComponents = filteredComponents.map(comp => {
                    let new_ids = comp.node_ids.split(";").filter(id => finalNodeIds.has(id));
                    let newComp = Object.assign({}, comp);
                    newComp.node_ids = new_ids.join(";");
                    return newComp;
                }).filter(comp => comp.node_ids.trim() !== "");
                let finalNodes = nodesData.filter(n => finalNodeIds.has(n.id));
                let finalEdges = allowedEdges.filter(e => finalNodeIds.has(e.source) && finalNodeIds.has(e.target));
                if (document.getElementById("removeIsolatedNodes").checked) {
                    const connectedIds = new Set();
                    finalEdges.forEach(e => {
                        connectedIds.add(e.source);
                        connectedIds.add(e.target);
                    });
                    finalNodes = finalNodes.filter(n => connectedIds.has(n.id));
                    finalEdges = finalEdges.filter(e => connectedIds.has(e.source) && connectedIds.has(e.target));
                    finalComponents = finalComponents.map(comp => {
                        let new_ids = comp.node_ids.split(";").filter(id => finalNodes.some(n => n.id === id));
                        let newComp = Object.assign({}, comp);
                        newComp.node_ids = new_ids.join(";");
                        return newComp;
                    }).filter(comp => comp.node_ids.trim() !== "");
                }
                $('#nodesTable').DataTable().clear().rows.add(finalNodes).draw();
                $('#componentsTable').DataTable().clear().rows.add(finalComponents).draw();
                const uniqueGenes = new Set(finalNodes.map(n => n.gene_name).filter(g => g && g.toLowerCase() !== "unknown"));
                const statsBox = document.getElementById("statsBox");
                statsBox.classList.remove("d-none");
                statsBox.innerHTML = `${finalNodes.length} nodes, ${finalEdges.length} edges, ${finalComponents.length} component(s), ${uniqueGenes.size} unique gene(s).`;
                return { finalNodes, finalEdges, finalComponents };
            }

            // Create or update graph in modal container.
            function createOrUpdateModalGraph(nodes, edges) {
                const container = document.getElementById("graphFullscreenContainer");
                container.innerHTML = "";
                container.style.position = "relative";

                // Build control panel with numeric inputs alongside sliders.
                const controlPanel = document.createElement("div");
                controlPanel.style.position = "absolute";
                controlPanel.style.top = "10px";
                controlPanel.style.left = "10px";
                controlPanel.style.zIndex = "1000";
                controlPanel.style.background = "rgba(255,255,255,0.8)";
                controlPanel.style.padding = "10px";
                controlPanel.style.borderRadius = "4px";
                controlPanel.innerHTML = `
          <select id="modal_visualizationMode" class="form-select form-select-sm mb-2">
            <option value="regions" selected>By Regions</option>
            <option value="genes">By Genes</option>
          </select>
          <div class="form-check mb-2">
            <input class="form-check-input" type="checkbox" id="modal_useActualOverlaps">
            <label class="form-check-label" for="modal_useActualOverlaps">
              Use Actual BP Overlaps
            </label>
            <i class="bi bi-info-circle ms-1" 
               data-bs-toggle="tooltip" 
               title="Calculate and visualize actual base pair overlaps between regions"></i>
          </div>
          <input type="text" id="modal_search" class="form-control form-control-sm mb-2" placeholder="Search nodes by gene">
          <button type="button" id="modal_searchButton" class="btn btn-primary btn-sm mb-2">Search</button>
          <select id="modal_layoutSelect" class="form-select form-select-sm mb-2">
            <option value="force">Force Directed</option>
            <option value="hierarchical">Hierarchical</option>
            <option value="circular">Circular</option>
          </select>
          <div class="mb-2">
            <label for="modal_nodeSize" class="form-label mb-0" style="font-size: 0.8rem;">Node Size</label>
            <div class="input-group input-group-sm">
              <input type="range" id="modal_nodeSize" class="form-range" min="5" max="50" value="10" step="1">
              <input type="number" id="modal_nodeSizeNumber" class="form-control" value="10" min="5" max="50" step="1" style="max-width:80px;">
            </div>
          </div>
          <div class="mb-2">
            <label for="modal_labelSize" class="form-label mb-0" style="font-size: 0.8rem;">Label Font Size</label>
            <div class="input-group input-group-sm">
              <input type="range" id="modal_labelSize" class="form-range" min="10" max="30" value="14" step="1">
              <input type="number" id="modal_labelSizeNumber" class="form-control" value="14" min="10" max="30" step="1" style="max-width:80px;">
            </div>
          </div>
          <div class="mb-2">
            <label for="modal_edgeWeightSelect" class="form-label mb-0" style="font-size: 0.8rem;">Edge Weight Attribute</label>
            <select id="modal_edgeWeightSelect" class="form-select form-select-sm">
              <option value="">None</option>
            </select>
          </div>
          <div class="d-grid gap-2">
            <button type="button" id="modal_clearSelection" class="btn btn-sm btn-outline-secondary">Clear Selection</button>
          </div>
        `;
                container.appendChild(controlPanel);

                // Populate edge weight selector.
                const modalEdgeWeightSelect = document.getElementById("modal_edgeWeightSelect");
                if (edgesColumns && edgesColumns.length > 0) {
                    let opts = "";
                    edgesColumns.filter(col => !["source", "target", "node", "node_name"].includes(col.toLowerCase()))
                        .forEach(col => { opts += `<option value="${col}">${col}</option>`; });
                    modalEdgeWeightSelect.innerHTML += opts;
                }

                // Create graph div.
                const graphDiv = document.createElement("div");
                graphDiv.id = "graphFullscreen";
                graphDiv.style.height = "calc(100% - 220px)";
                container.appendChild(graphDiv);

                // Get references for node and label size controls.
                const nodeSizeRange = document.getElementById("modal_nodeSize");
                const nodeSizeNumber = document.getElementById("modal_nodeSizeNumber");
                const labelSizeRange = document.getElementById("modal_labelSize");
                const labelSizeNumber = document.getElementById("modal_labelSizeNumber");

                // Parse a region string like "chr1:1000-2000" into {chr, start, end}
                function parseRegion(regionStr) {
                    try {
                        const [chr, range] = regionStr.split(':');
                        const [start, end] = range.split('-').map(Number);
                        return { chr, start, end };
                    } catch (e) {
                        console.error("Error parsing region:", regionStr, e);
                        return null;
                    }
                }

                // Calculate base pair overlap between two regions
                function calculateOverlap(region1, region2) {
                    // If regions are on different chromosomes, use length-based calculation
                    if (region1.chr !== region2.chr) {
                        // Calculate the absolute length of each region
                        const length1 = region1.end - region1.start;
                        const length2 = region2.end - region2.start;
                        // The overlap is the minimum length of the two regions
                        return Math.min(length1, length2);
                    } else {
                        // For regions on the same chromosome, calculate standard overlap
                        const overlapStart = Math.max(region1.start, region2.start);
                        const overlapEnd = Math.min(region1.end, region2.end);
                        
                        if (overlapStart <= overlapEnd) {
                            // There is an actual overlap on the chromosome
                            return overlapEnd - overlapStart;
                        } else {
                            // No overlap on the same chromosome - calculate common length
                            const length1 = region1.end - region1.start;
                            const length2 = region2.end - region2.start;
                            return Math.min(length1, length2);
                        }
                    }
                }

                // Compute edge overlaps for all edges between regions
                function computeRegionOverlaps(nodes, edges) {
                    // Create a mapping of node IDs to parsed regions
                    const regionMap = {};
                    nodes.forEach(node => {
                        regionMap[node.id] = parseRegion(node.id);
                    });

                    // Calculate actual overlaps for each edge
                    return edges.map(edge => {
                        const sourceRegion = regionMap[edge.source];
                        const targetRegion = regionMap[edge.target];

                        if (sourceRegion && targetRegion) {
                            const bpOverlap = calculateOverlap(sourceRegion, targetRegion);
                            return {
                                ...edge,
                                bp_overlap: bpOverlap
                            };
                        }

                        return edge;
                    });
                }

                // Calculate edges with overlap information once
                const edgesWithOverlaps = computeRegionOverlaps(nodes, edges);

                // Function to compute modal graph data.
                function computeModalGraphData() {
                    const visMode = document.getElementById("modal_visualizationMode").value;
                    const useActualOverlaps = document.getElementById("modal_useActualOverlaps").checked;
                    let graphNodes, graphEdges;

                    if (visMode === "genes") {
                        let regionToGene = {};
                        nodes.forEach(n => { regionToGene[n.id] = n.gene_name ? n.gene_name : n.id; });
                        let geneGroups = {};
                        nodes.forEach(n => {
                            let gene = n.gene_name ? n.gene_name : n.id;
                            if (!geneGroups[gene]) geneGroups[gene] = [];
                            geneGroups[gene].push(n);
                        });
                        graphNodes = Object.keys(geneGroups).map(gene => ({
                            id: gene,
                            label: gene,
                            title: `Gene: ${gene} (${geneGroups[gene].length} regions)`,
                            gene: gene.toLowerCase(),
                            size: parseInt(nodeSizeRange.value),
                            originalColor: {}
                        }));

                        // For genes mode with actual overlaps
                        let edgeMap = {};
                        if (useActualOverlaps) {
                            // When using actual overlaps, sum the bp_overlap values
                            edgesWithOverlaps.forEach(e => {
                                let geneA = regionToGene[e.source];
                                let geneB = regionToGene[e.target];
                                if (!geneA || !geneB || geneA === geneB) return;

                                let key = geneA < geneB ? `${geneA}|${geneB}` : `${geneB}|${geneA}`;
                                if (!edgeMap[key]) {
                                    edgeMap[key] = {
                                        from: geneA,
                                        to: geneB,
                                        count: 0,
                                        totalOverlap: 0
                                    };
                                }
                                edgeMap[key].count++;
                                edgeMap[key].totalOverlap += (e.bp_overlap || 0);
                            });
                        } else {
                            // Original behavior - count connections
                            edges.forEach(e => {
                                let geneA = regionToGene[e.source];
                                let geneB = regionToGene[e.target];
                                if (!geneA || !geneB || geneA === geneB) return;

                                let key = geneA < geneB ? `${geneA}|${geneB}` : `${geneB}|${geneA}`;
                                if (!edgeMap[key]) {
                                    edgeMap[key] = {
                                        from: geneA,
                                        to: geneB,
                                        count: 0
                                    };
                                }
                                edgeMap[key].count++;
                            });
                        }

                        graphEdges = Object.values(edgeMap).map(e => {
                            let title = `Edge between ${e.from} and ${e.to} (${e.count} connections)`;
                            if (useActualOverlaps && e.totalOverlap) {
                                title += `\nTotal overlap: ${e.totalOverlap.toLocaleString()} bp`;
                            }
                            return {
                                from: e.from,
                                to: e.to,
                                title: title,
                                width: 2,
                                count: e.count,
                                bp_overlap: e.totalOverlap || 0
                            };
                        });
                    } else {
                        // By Regions
                        graphNodes = nodes.map(n => {
                            const label = n.gene_name && n.gene_name !== "unknown" ? `${n.gene_name} (${n.id})` : n.id;
                            return {
                                id: n.id,
                                label: label,
                                title: `Gene: ${n.gene_name}\nID: ${n.id}`,
                                gene: n.gene_name ? n.gene_name.toLowerCase() : n.id.toLowerCase(),
                                size: parseInt(nodeSizeRange.value),
                                originalColor: {}
                            };
                        });

                        if (useActualOverlaps) {
                            // Use pre-calculated overlaps for edges
                            graphEdges = edgesWithOverlaps.map((e, i) => {
                                let title = Object.entries(e)
                                    .filter(([k]) => !["source", "target"].includes(k))
                                    .map(([k, v]) => `${k}: ${v}`)
                                    .join("\n");

                                if (e.bp_overlap !== undefined) {
                                    title += `\nActual overlap: ${e.bp_overlap.toLocaleString()} bp`;
                                }

                                return {
                                    id: i,
                                    from: e.source,
                                    to: e.target,
                                    title: title,
                                    width: 2,
                                    bp_overlap: e.bp_overlap || 0
                                };
                            });
                        } else {
                            // Original behavior
                            graphEdges = edges.map((e, i) => ({
                                id: i,
                                from: e.source,
                                to: e.target,
                                title: Object.entries(e).map(([k, v]) => `${k}: ${v}`).join("\n"),
                                width: 2
                            }));
                        }
                    }
                    return { graphNodes, graphEdges };
                }

                let { graphNodes, graphEdges } = computeModalGraphData();
                modalNetworkData.nodes = new vis.DataSet(graphNodes);
                modalNetworkData.edges = new vis.DataSet(graphEdges);
                let options = {
                    layout: { improvedLayout: false },
                    physics: {
                        stabilization: true,
                        barnesHut: { gravitationalConstant: -20000, springLength: 250 }
                    },
                    interaction: { tooltipDelay: 200, hover: true },
                    nodes: {
                        shape: 'dot',
                        size: parseInt(nodeSizeRange.value),
                        font: { size: parseInt(labelSizeRange.value), color: '#343a40' }
                    },
                    edges: { width: 2 }
                };
                modalNetwork = new vis.Network(graphDiv, {
                    nodes: modalNetworkData.nodes,
                    edges: modalNetworkData.edges
                }, options);

                // Save original colors.
                modalNetworkData.nodes.get().forEach(node => {
                    modalNetworkData.nodes.update({ id: node.id, originalColor: node.color || {} });
                });

                // Attach event listeners for control panel.
                document.getElementById("modal_visualizationMode").addEventListener("change", function () {
                    const newData = computeModalGraphData();
                    modalNetworkData.nodes.clear();
                    modalNetworkData.nodes.add(newData.graphNodes);
                    modalNetworkData.edges.clear();
                    modalNetworkData.edges.add(newData.graphEdges);
                });

                // Sync node size controls.
                nodeSizeRange.addEventListener("input", () => {
                    nodeSizeNumber.value = nodeSizeRange.value;
                    if (modalNetworkData.nodes) {
                        modalNetworkData.nodes.get().forEach(node => {
                            modalNetworkData.nodes.update({ id: node.id, size: parseInt(nodeSizeRange.value) });
                        });
                        modalNetwork.redraw();
                    }
                });
                nodeSizeNumber.addEventListener("change", () => {
                    nodeSizeRange.value = nodeSizeNumber.value;
                    if (modalNetworkData.nodes) {
                        modalNetworkData.nodes.get().forEach(node => {
                            modalNetworkData.nodes.update({ id: node.id, size: parseInt(nodeSizeRange.value) });
                        });
                        modalNetwork.redraw();
                    }
                });

                // Sync label size controls.
                labelSizeRange.addEventListener("input", () => {
                    labelSizeNumber.value = labelSizeRange.value;
                    modalNetwork.setOptions({ nodes: { font: { size: parseInt(labelSizeRange.value) } } });
                });
                labelSizeNumber.addEventListener("change", () => {
                    labelSizeRange.value = labelSizeNumber.value;
                    modalNetwork.setOptions({ nodes: { font: { size: parseInt(labelSizeRange.value) } } });
                });

                document.getElementById("modal_searchButton").addEventListener("click", function () {
                    const searchTerm = document.getElementById("modal_search").value.trim().toLowerCase();
                    if (modalNetworkData.nodes) {
                        modalNetworkData.nodes.get().forEach(function (node) {
                            let orig = node.originalColor || {};
                            if (searchTerm !== "" &&
                                (node.gene.includes(searchTerm) || searchTerm.includes(node.gene)) &&
                                (node.gene.length >= searchTerm.length || node.gene.length === searchTerm.length - 1)) {
                                modalNetworkData.nodes.update({ id: node.id, color: { background: 'yellow' } });
                            } else {
                                modalNetworkData.nodes.update({ id: node.id, color: orig });
                            }
                        });
                    }
                });

                // Clear selection resets search and all node colors.
                document.getElementById("modal_clearSelection").addEventListener("click", function () {
                    document.getElementById("modal_search").value = "";
                    if (modalNetworkData.nodes) {
                        modalNetworkData.nodes.get().forEach(function (node) {
                            modalNetworkData.nodes.update({ id: node.id, color: node.originalColor || {} });
                        });
                        modalNetwork.redraw();
                    }
                    modalNetwork.unselectAll();
                });

                document.getElementById("modal_layoutSelect").addEventListener("change", function () {
                    const layoutType = this.value;
                    if (layoutType === "hierarchical") {
                        modalNetwork.setOptions({ layout: { hierarchical: { enabled: true, direction: 'UD', sortMethod: 'directed' } } });
                    } else if (layoutType === "circular") {
                        modalNetwork.setOptions({ physics: false });
                        const rect = graphDiv.getBoundingClientRect();
                        const centerX = rect.width / 2, centerY = rect.height / 2, radius = Math.min(rect.width, rect.height) / 3;
                        modalNetworkData.nodes.get().forEach((node, index) => {
                            const angle = 2 * Math.PI * index / modalNetworkData.nodes.get().length;
                            modalNetworkData.nodes.update({ id: node.id, x: centerX + radius * Math.cos(angle), y: centerY + radius * Math.sin(angle), fixed: { x: true, y: true } });
                        });
                    } else {
                        modalNetwork.setOptions({ layout: { hierarchical: false } });
                        modalNetwork.setOptions({ physics: { stabilization: true } });
                        modalNetworkData.nodes.get().forEach(node => {
                            modalNetworkData.nodes.update({ id: node.id, fixed: false });
                        });
                    }
                });

                document.getElementById("modal_edgeWeightSelect").addEventListener("change", function () {
                    const attr = this.value;
                    updateEdgeWeights(attr);
                });

                // Fix edge weight function
                function updateEdgeWeights(attr) {
                    if (attr === "") {
                        modalNetworkData.edges.get().forEach(edge => {
                            modalNetworkData.edges.update({ id: edge.id, width: 2 });
                        });
                        return;
                    }

                    // Collect values for scaling
                    let values = [];
                    modalNetworkData.edges.get().forEach(edge => {
                        // Check if the attribute exists directly on the edge object first
                        if (edge[attr] !== undefined) {
                            let val = parseFloat(edge[attr]);
                            if (!isNaN(val)) values.push(val);
                        }
                        // If not found in edge object, check in the original data
                        else {
                            let edgeData;
                            if (document.getElementById("modal_useActualOverlaps").checked) {
                                edgeData = edgesWithOverlaps.find(e =>
                                    (e.source === edge.from && e.target === edge.to) ||
                                    (e.source === edge.to && e.target === edge.from)
                                );
                            } else {
                                edgeData = edges.find(e =>
                                    (e.source === edge.from && e.target === edge.to) ||
                                    (e.source === edge.to && e.target === edge.from)
                                );
                            }

                            if (edgeData && edgeData[attr] !== undefined) {
                                let val = parseFloat(edgeData[attr]);
                                if (!isNaN(val)) values.push(val);
                            }
                        }
                    });

                    // Apply scaling
                    if (values.length > 0) {
                        const minVal = Math.min(...values);
                        const maxVal = Math.max(...values);
                        const minWidth = 1, maxWidth = 10;

                        modalNetworkData.edges.get().forEach(edge => {
                            let value;

                            // Try to get value from the edge object first
                            if (edge[attr] !== undefined) {
                                value = parseFloat(edge[attr]);
                            }
                            // If not found, look in original data
                            else {
                                let edgeData;
                                if (document.getElementById("modal_useActualOverlaps").checked) {
                                    edgeData = edgesWithOverlaps.find(e =>
                                        (e.source === edge.from && e.target === edge.to) ||
                                        (e.source === edge.to && e.target === edge.from)
                                    );
                                } else {
                                    edgeData = edges.find(e =>
                                        (e.source === edge.from && e.target === edge.to) ||
                                        (e.source === edge.to && e.target === edge.from)
                                    );
                                }

                                if (edgeData) {
                                    value = parseFloat(edgeData[attr]);
                                }
                            }

                            if (!isNaN(value)) {
                                let normalized = minVal === maxVal
                                    ? (minWidth + maxWidth) / 2
                                    : minWidth + ((value - minVal) / (maxVal - minVal)) * (maxWidth - minWidth);

                                modalNetworkData.edges.update({
                                    id: edge.id,
                                    width: normalized,
                                    title: edge.title + `\n${attr}: ${value.toLocaleString()}`
                                });
                            }
                        });
                    }
                }

                // Update the edge weight dropdown to include bp_overlap
                const edgeWeightSelect = document.getElementById("modal_edgeWeightSelect");
                if (!Array.from(edgeWeightSelect.options).some(opt => opt.value === "bp_overlap")) {
                    const bpOption = document.createElement("option");
                    bpOption.value = "bp_overlap";
                    bpOption.textContent = "BP Overlap";
                    edgeWeightSelect.appendChild(bpOption);
                }
                if (!Array.from(edgeWeightSelect.options).some(opt => opt.value === "count")) {
                    const countOption = document.createElement("option");
                    countOption.value = "count";
                    countOption.textContent = "Connection Count";
                    edgeWeightSelect.appendChild(countOption);
                }

                // Tooltip for copying node name.
                const copyTooltip = document.getElementById("copyTooltip");
                graphDiv.addEventListener("mousemove", function (e) {
                    if (copyTooltip.style.display === "block") {
                        copyTooltip.style.left = (e.pageX + 10) + "px";
                        copyTooltip.style.top = (e.pageY + 10) + "px";
                    }
                });
                modalNetwork.on("hoverNode", function (params) {
                    const nodeId = params.node;
                    const node = modalNetworkData.nodes.get(nodeId);
                    if (node) {
                        copyTooltip.textContent = "Copy: " + node.label;
                        copyTooltip.style.display = "block";
                        copyTooltip.style.left = (params.event.pageX + 10) + "px";
                        copyTooltip.style.top = (params.event.pageY + 10) + "px";
                    }
                });
                modalNetwork.on("blurNode", function () {
                    copyTooltip.style.display = "none";
                });
                copyTooltip.addEventListener("click", function () {
                    const text = copyTooltip.textContent.replace("Copy: ", "");
                    navigator.clipboard.writeText(text).then(() => {
                        copyTooltip.textContent = "Copied!";
                        setTimeout(() => { copyTooltip.style.display = "none"; }, 1000);
                    });
                });

                // Attach event listener for the overlap mode toggle
                document.getElementById("modal_useActualOverlaps").addEventListener("change", function () {
                    const newData = computeModalGraphData();
                    modalNetworkData.nodes.clear();
                    modalNetworkData.nodes.add(newData.graphNodes);
                    modalNetworkData.edges.clear();
                    modalNetworkData.edges.add(newData.graphEdges);

                    // Update edge weights if selected
                    const edgeWeightAttr = document.getElementById("modal_edgeWeightSelect").value;
                    if (edgeWeightAttr) {
                        updateEdgeWeights(edgeWeightAttr);
                    }
                });
            }

            // Show graph modal.
            function showGraphModal(nodes, edges) {
                if (nodes.length > 1000) {
                    alert("Visualization aborted: More than 1000 nodes to display.");
                    return;
                }
                if (modalNetwork) {
                    // Update modal network data.
                    const newData = (function computeModalData() {
                        const visMode = document.getElementById("modal_visualizationMode").value;
                        let graphNodes, graphEdges;
                        if (visMode === "genes") {
                            let regionToGene = {};
                            nodes.forEach(n => { regionToGene[n.id] = n.gene_name ? n.gene_name : n.id; });
                            let geneGroups = {};
                            nodes.forEach(n => {
                                let gene = n.gene_name ? n.gene_name : n.id;
                                if (!geneGroups[gene]) geneGroups[gene] = [];
                                geneGroups[gene].push(n);
                            });
                            graphNodes = Object.keys(geneGroups).map(gene => ({
                                id: gene,
                                label: gene,
                                title: `Gene: ${gene} (${geneGroups[gene].length} regions)`,
                                gene: gene.toLowerCase(),
                                size: parseInt(document.getElementById("modal_nodeSize").value),
                                originalColor: {}
                            }));
                            let edgeMap = {};
                            edges.forEach(e => {
                                let geneA = regionToGene[e.source];
                                let geneB = regionToGene[e.target];
                                if (!geneA || !geneB || geneA === geneB) return;
                                let key = geneA < geneB ? geneA + "|" + geneB : geneB + "|" + geneA;
                                if (!edgeMap[key]) { edgeMap[key] = { from: geneA, to: geneB, count: 0 }; }
                                edgeMap[key].count++;
                            });
                            graphEdges = Object.values(edgeMap).map(e => ({
                                from: e.from,
                                to: e.to,
                                title: `Edge between ${e.from} and ${e.to} (${e.count} connections)`,
                                width: 2
                            }));
                        } else {
                            graphNodes = nodes.map(n => {
                                const label = n.gene_name && n.gene_name !== "unknown" ? `${n.gene_name} (${n.id})` : n.id;
                                return {
                                    id: n.id,
                                    label: label,
                                    title: `Gene: ${n.gene_name}\nID: ${n.id}`,
                                    gene: n.gene_name ? n.gene_name.toLowerCase() : n.id.toLowerCase(),
                                    size: parseInt(document.getElementById("modal_nodeSize").value),
                                    originalColor: {}
                                };
                            });
                            graphEdges = edges.map((e, i) => ({
                                id: i,
                                from: e.source,
                                to: e.target,
                                title: Object.entries(e).map(([k, v]) => `${k}: ${v}`).join("\n"),
                                width: 2
                            }));
                        }
                        return { graphNodes, graphEdges };
                    })();
                    modalNetworkData.nodes.clear();
                    modalNetworkData.nodes.add(newData.graphNodes);
                    modalNetworkData.edges.clear();
                    modalNetworkData.edges.add(newData.graphEdges);
                } else {
                    createOrUpdateModalGraph(nodes, edges);
                }
                const modalEl = document.getElementById("graphFullscreenModal");
                const modal = new bootstrap.Modal(modalEl);
                modal.show();
            }

            // Download and share functions remain unchanged.
            function downloadZip(finalNodes, finalEdges) {
                const zip = new JSZip();
                zip.file("filtered_nodes.tsv", toTSV(finalNodes));
                zip.file("filtered_edges.tsv", toTSV(finalEdges));
                zip.file("filtered_nodes.bed", toBED(finalNodes));
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentNodes = finalNodes.filter(n => fullComponentIds.has(n.id));
                const fullComponentEdges = finalEdges.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
                zip.file("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
                zip.file("filtered_nodes_full_component.bed", toBED(fullComponentNodes));
                zip.generateAsync({ type: "blob" }).then(file => {
                    const prefix = document.getElementById("filePrefix").value || "";
                    downloadFile(file, prefix + "filtered_data.zip", "application/zip");
                });
            }

            function downloadIndividualFile(filename, content) {
                const prefix = document.getElementById("filePrefix").value || "";
                downloadFile(content, prefix + filename, "text/plain");
            }

            function downloadComponentsTSV(finalComponents) {
                downloadIndividualFile("filtered_components.tsv", toTSV(finalComponents));
            }

            function downloadComponentsZip(finalComponents, finalNodes) {
                const zip = new JSZip();
                finalComponents.forEach(comp => {
                    const compNodeIds = comp.node_ids.split(";");
                    const compNodes = finalNodes.filter(n => compNodeIds.includes(n.id));
                    zip.file(`component_${comp.component_id}.bed`, toBED(compNodes));
                });
                zip.generateAsync({ type: "blob" }).then(file => {
                    const prefix = document.getElementById("filePrefix").value || "";
                    downloadFile(file, prefix + "separated_components.zip", "application/zip");
                });
            }

            document.getElementById("downloadZip").addEventListener("click", () => {
                const { finalNodes, finalEdges, finalComponents } = applyFiltersAll();
                downloadZip(finalNodes, finalEdges);
            });
            document.getElementById("downloadNodesTsv").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                downloadIndividualFile("filtered_nodes.tsv", toTSV(finalNodes));
            });
            document.getElementById("downloadEdgesTsv").addEventListener("click", () => {
                const { finalEdges } = applyFiltersAll();
                downloadIndividualFile("filtered_edges.tsv", toTSV(finalEdges));
            });
            document.getElementById("downloadNodesBed").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                downloadIndividualFile("filtered_nodes.bed", toBED(finalNodes));
            });
            document.getElementById("downloadFullEdgesTsv").addEventListener("click", () => {
                const { finalNodes, finalEdges } = applyFiltersAll();
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentEdges = finalEdges.filter(e => fullComponentIds.has(e.source) && fullComponentIds.has(e.target));
                downloadIndividualFile("filtered_edges_full_component.tsv", toTSV(fullComponentEdges));
            });
            document.getElementById("downloadFullNodesBed").addEventListener("click", () => {
                const { finalNodes } = applyFiltersAll();
                const finalIds = new Set(finalNodes.map(n => n.id));
                const adj = {};
                finalNodes.forEach(n => { adj[n.id] = []; });
                const { finalEdges } = applyFiltersAll();
                finalEdges.forEach(e => {
                    if (adj[e.source] && finalIds.has(e.target)) { adj[e.source].push(e.target); }
                    if (adj[e.target] && finalIds.has(e.source)) { adj[e.target].push(e.source); }
                });
                const visited = new Set();
                const fullComponentIds = new Set();
                function dfs(nodeId) {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    fullComponentIds.add(nodeId);
                    (adj[nodeId] || []).forEach(neighbor => dfs(neighbor));
                }
                finalNodes.forEach(n => { if (!visited.has(n.id)) dfs(n.id); });
                const fullComponentNodes = finalNodes.filter(n => fullComponentIds.has(n.id));
                downloadIndividualFile("filtered_nodes_full_component.bed", toBED(fullComponentNodes));
            });
            document.getElementById("downloadComponentsTsv").addEventListener("click", () => {
                const { finalComponents } = applyFiltersAll();
                downloadComponentsTSV(finalComponents);
            });
            document.getElementById("downloadComponentsZip").addEventListener("click", () => {
                const { finalComponents, finalNodes } = applyFiltersAll();
                downloadComponentsZip(finalComponents, finalNodes);
            });

            document.getElementById("shareResults").onclick = shareResults;
            document.getElementById("applyFilters").onclick = () => {
                applyFiltersAll();
            };
            document.getElementById("visualizeGraph").onclick = () => {
                const { finalNodes, finalEdges } = applyFiltersAll();
                showGraphModal(finalNodes, finalEdges);
            };

            document.getElementById("addNodeFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("nodesFiltersContainer"), nodesColumns, nodesColumnTypes);
            });
            document.getElementById("addEdgeFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("edgesFiltersContainer"), edgesColumns, edgesColumnTypes);
            });
            document.getElementById("addComponentFilter").addEventListener("click", () => {
                addDynamicFilterRow(document.getElementById("componentsFiltersContainer"), componentsColumns, componentsColumnTypes);
            });

            $('#nodesTable').DataTable({ data: [], columns: [] });
            $('#componentsTable').DataTable({ data: [], columns: [] });

            loadTSV("nodes_metadata.tsv", (data, cols) => {
                nodesData = data;
                nodesColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    nodesColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                geneList = [...new Set(data.map(d => d.gene_name).filter(g => g !== "unknown"))];
                $('#nodesTable').DataTable().destroy();
                $('#nodesTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
                loadShareState();
            });
            loadTSV("edges.tsv", (data, cols) => {
                edgesData = data;
                edgesColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    edgesColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
            });
            loadTSV("connected_components_summary.tsv", (data, cols) => {
                componentsData = data;
                componentsColumns = cols;
                cols.forEach(col => {
                    const firstVal = data[0][col];
                    componentsColumnTypes[col] = (!isNaN(parseFloat(firstVal)) && isFinite(firstVal)) ? "number" : "categorical";
                });
                $('#componentsTable').DataTable().destroy();
                $('#componentsTable').DataTable({ data: [], columns: cols.map(c => ({ title: c, data: c })) });
            });
        });
    </script>
</body>

</html>